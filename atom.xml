<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XueCat</title>
  <subtitle>用代码创造世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuecat.github.io/"/>
  <updated>2018-07-12T16:53:29.982Z</updated>
  <id>https://xuecat.github.io/</id>
  
  <author>
    <name>XueCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql检索(239)</title>
    <link href="https://xuecat.github.io/2018/07/13/239/"/>
    <id>https://xuecat.github.io/2018/07/13/239/</id>
    <published>2018-07-12T16:49:11.000Z</published>
    <updated>2018-07-12T16:53:29.982Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Å, å，这是丹麦的</div><div class="line">Ä ä，这是德语的</div><div class="line">A <span class="selector-tag">a</span> 这是英文得</div></pre></td></tr></table></figure>
<p>mysql里校对包含字符时有这些<code>like</code> <code>instr</code> <code>locate</code>,<br>但它们时建立在一个校对规则之上的,<br><code>_unicode_ci</code>不区分大小写<br><code>_general_ci</code>不区分大小写<br><code>*_cs</code>区分大小写<br><code>*_bin</code>用二进制存储</p>
<p>utf8_general_ci 校对速度快，但准确度稍差<br>utf8_unicode_ci 准确度高，但校对速度稍慢(所以最近那个sql问题我该改成这个)</p>
<p>utf8mb4字符集可以保存表情符号.</p>
<p>最后直接限定字符检索才成功，不明白为何改<code>_bin</code>也不成功。唉！<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbp_log_object <span class="keyword">as</span> a <span class="keyword">WHERE</span> <span class="keyword">locate</span>(<span class="string">'Ä'</span> <span class="keyword">collate</span> utf8_bin, a.objectname)&gt;<span class="number">0</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>orleans(238)</title>
    <link href="https://xuecat.github.io/2018/07/06/238/"/>
    <id>https://xuecat.github.io/2018/07/06/238/</id>
    <published>2018-07-06T13:00:29.000Z</published>
    <updated>2018-07-10T16:00:54.411Z</updated>
    
    <content type="html"><![CDATA[<p>这个亚马逊云素材同步代码是我至今最大坡度的代码<br>第一次有种想早点下班好回去恶补知识的感觉,可惜又不得不加班完成任务。</p>
<ol>
<li>silo 代表一个服务，可以是主节点也可以是副节点</li>
<li><p>grain 可以看作是一个单例进程，队列只有一个，会排队修改数据。相同类型的只要key不同，它们就互相独立</p>
</li>
<li><p>客户端一开始就会连接一个服务即silo.(GrainClient.Initialize)</p>
</li>
<li><p>StreamProvider订阅，无论是隐式还是显式，都要用this.stream.OnNextAsync(data)去分发<br>显式还是隐式都是一个grain，初始化注册订阅后才能使用</p>
</li>
</ol>
<ol>
<li><p>Orleans.Immutable 这个是由于和grain的方法调用传参是一次深拷贝<br>grain之间通信，silo之间通信也是深拷贝。<br>为了避免，所以用这个来控制，避免深拷贝。</p>
</li>
<li><p>Orleans永远不会在执行Task的中途创造另一个Task,所以要求程序代码在执行Task的中途,不要开辟多线程.不然会报错或者会破坏单线程机制.如果真的有需要创造额外的task.</p>
</li>
<li><p><code>StatelessWorker</code>的<code>grain</code>，状态无关类型；可以在集群的多个silo里,每一个silo都创造一个相同标识的Grain。 针对此类grain的请求,都只在第一个接受到请求的silo里执行。 Orleans会在所有此类grain忙的时候,自动增加一个</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个亚马逊云素材同步代码是我至今最大坡度的代码&lt;br&gt;第一次有种想早点下班好回去恶补知识的感觉,可惜又不得不加班完成任务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;silo 代表一个服务，可以是主节点也可以是副节点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;grain 可以看作是一个单例进程，队列只有一个
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="分布式" scheme="https://xuecat.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>せいかつの日記(237)</title>
    <link href="https://xuecat.github.io/2018/07/04/237/"/>
    <id>https://xuecat.github.io/2018/07/04/237/</id>
    <published>2018-07-03T16:06:56.000Z</published>
    <updated>2018-07-10T15:37:53.627Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/237.png" alt=""></p>
<hr>
<pre><code>見ないでくたさい、ただ馬鹿な話しです
</code></pre><hr>
<h2 id="2018-7-3"><a href="#2018-7-3" class="headerlink" title="2018/7/3"></a>2018/7/3</h2><p>やっと、reactのプロジェクトおわりました、少しごめなことあるですけれど。</p>
<p>も、次の仕事用意してる</p>
<p>Amazon cloud synchronization</p>
<p>ああ！！メチや　メチや、難しいです；頭もだめちや</p>
<h2 id="2018-7-6"><a href="#2018-7-6" class="headerlink" title="2018/7/6"></a>2018/7/6</h2><p>ああ！あ！　ついに、負け犬をなちゃた<br>残業中に食物をあげで、そんな事はまったく思わなかったです。<br>相手は強すぎる、俺は彼の前に全然駄目です。<br>ちょっとだけない。。。。。、悲しいです。<br>どうするつもり、僕もわからない。<br>せめて答えをもらう</p>
<h2 id="2018-7-9"><a href="#2018-7-9" class="headerlink" title="2018/7/9"></a>2018/7/9</h2><p>山なほと仕事<br>恋は雨上がりのように</p>
<h2 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018/7/10"></a>2018/7/10</h2><p>父さんと母さんがきちゃった、猫も</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/237.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;見ないでくたさい、ただ馬鹿な話しです
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;2018-7-3&quot;&gt;&lt;a href=&quot;#2018-7-3&quot; class=
    
    </summary>
    
      <category term="生活" scheme="https://xuecat.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>decimal类型(236)</title>
    <link href="https://xuecat.github.io/2018/06/30/236/"/>
    <id>https://xuecat.github.io/2018/06/30/236/</id>
    <published>2018-06-30T07:59:25.000Z</published>
    <updated>2018-06-30T11:51:21.733Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>js forin顺序(235)</title>
    <link href="https://xuecat.github.io/2018/06/17/235/"/>
    <id>https://xuecat.github.io/2018/06/17/235/</id>
    <published>2018-06-17T06:21:10.000Z</published>
    <updated>2018-06-17T06:46:47.867Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/235.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>平时根本没时间写着，只好全缓存，周末更新上来，唉！！
得找个时间再去看下markdown语法了，排版真特么丑。
</code></pre><p>装逼封装了excel读写的js，forin排序居然用到了，笔记下：</p>
<pre><code>js for in顺序，不会按照定义顺序输出；好像浏览器没按以前标准了;
它处理方式是先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>stl的swap和(234)</title>
    <link href="https://xuecat.github.io/2018/06/17/234/"/>
    <id>https://xuecat.github.io/2018/06/17/234/</id>
    <published>2018-06-17T06:02:20.000Z</published>
    <updated>2018-06-17T06:46:39.547Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/234.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>去p站下图片越来越少了
</code></pre><h3 id="string和vector"><a href="#string和vector" class="headerlink" title="string和vector"></a>string和vector</h3><p>它们都是线性结构，只不过是堆而已。<br>它们都有reserve的概念，所以导致它们的预定义内存</p>
<p>释放内存的方法就是都是用<code>swap</code>, <code>string().swap(s)</code></p>
<p><code>swap</code>交换技巧实现内存释放思想：</p>
<p><strong><em><code>vector()</code>使用<code>vector</code>的默认构造函数建立临时<code>vector</code>对象，再在该临对象上调用<code>swap</code>成员，<code>swap</code>调用之后对象<code>myvector</code>占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="STL" scheme="https://xuecat.github.io/categories/STL/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>c++CRTP和typename与class的区别233</title>
    <link href="https://xuecat.github.io/2018/05/26/233/"/>
    <id>https://xuecat.github.io/2018/05/26/233/</id>
    <published>2018-05-26T08:38:00.000Z</published>
    <updated>2018-06-17T06:25:24.194Z</updated>
    
    <content type="html"><![CDATA[<p><code>Curiously Recurring Template Prattern</code>即人们称的静态多态<br>由于c++的多态不能将基类的虚函数定义为模板函数，所以出现的它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> D&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(D t)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>).funcImpl(t);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base : <span class="keyword">public</span> BaseClass&lt;Base&gt;</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> BaseClass&lt;Derive&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	BaseClass&lt;Derive&gt; der;</div><div class="line">	der.Func(<span class="number">2</span>);<span class="comment">//base 2</span></div><div class="line"></div><div class="line">	BaseClass&lt;Base&gt; bas;</div><div class="line">	bas.Func(<span class="number">4</span>);<span class="comment">//derive 4</span></div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此，多态就能使用模板函数了</p>
<hr>
<p><strong>怕是最近js写多了，这个都忘了，羞愧啊！！</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> MyClass&#123;</div><div class="line">    <span class="keyword">typename</span> T::SubType * ptr;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，typename指出SubType是class T中定义的一个类别，因此ptr是一个指向T::SubType型别的指针。如果没有关键字typename，SubType会被当成一个static成员，于是<br>T::SubType * ptr<br>会被解释为型别T内的数值SubType与ptr的乘积。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Curiously Recurring Template Prattern&lt;/code&gt;即人们称的静态多态&lt;br&gt;由于c++的多态不能将基类的虚函数定义为模板函数，所以出现的它&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数据库遇见的一个问题(232)</title>
    <link href="https://xuecat.github.io/2018/05/06/232/"/>
    <id>https://xuecat.github.io/2018/05/06/232/</id>
    <published>2018-05-06T04:16:40.000Z</published>
    <updated>2018-05-06T04:21:10.090Z</updated>
    
    <content type="html"><![CDATA[<p>今天丹麦现场问题：<br>检索丹麦字符(长的像A,又不是A),出现英文A匹配和丹麦字符匹配。</p>
<p>最后发现是mysql的like语句，后面用locate语句精确才没把英文检索出来。<br>查了很久google和官方,并未给解释为啥like的模糊匹配是如此，大多讲locate比like高效。<br>所以写下记录，以后请问！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天丹麦现场问题：&lt;br&gt;检索丹麦字符(长的像A,又不是A),出现英文A匹配和丹麦字符匹配。&lt;/p&gt;
&lt;p&gt;最后发现是mysql的like语句，后面用locate语句精确才没把英文检索出来。&lt;br&gt;查了很久google和官方,并未给解释为啥like的模糊匹配是如此，大多讲l
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://xuecat.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>c++记录(231)</title>
    <link href="https://xuecat.github.io/2018/05/06/231/"/>
    <id>https://xuecat.github.io/2018/05/06/231/</id>
    <published>2018-05-06T04:03:21.000Z</published>
    <updated>2018-05-06T04:16:25.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a><strong><strong>数组检测</strong></strong></h2><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(<span class="number">0</span>[t]);<span class="comment">//可以检测这个是数组还是类：对数组来说0[t] t[0]都是一样的。但是对类来说，这是个操作函数(一定要实现它的operator函数哦)</span></div></pre></td></tr></table></figure>
</code></pre><h2 id="类完整性判断"><a href="#类完整性判断" class="headerlink" title="类完整性判断"></a><strong><strong>类完整性判断</strong></strong></h2><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">typedef</span> <span class="keyword">char</span> tt_f[<span class="keyword">sizeof</span>(f) ? <span class="number">1</span> : <span class="number">-1</span>];</div><div class="line">(<span class="keyword">void</span>)<span class="keyword">sizeof</span>(tt_f);</div><div class="line">   <span class="comment">//要注意sizeof的执行是编译期间执行的</span></div><div class="line">   <span class="comment">//所以当类不完整 sizof(f)为0; char[-1]就会编译错误</span></div></pre></td></tr></table></figure>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组检测&quot;&gt;&lt;a href=&quot;#数组检测&quot; class=&quot;headerlink&quot; title=&quot;数组检测&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;strong&gt;数组检测&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highl
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c#杂项笔记(230)</title>
    <link href="https://xuecat.github.io/2018/02/28/230/"/>
    <id>https://xuecat.github.io/2018/02/28/230/</id>
    <published>2018-02-28T15:34:14.000Z</published>
    <updated>2018-07-02T16:31:02.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p> 同步函数执行到async时会同步执行,当在async里遇见await时，会跳出async函数到外部继续执行。<br> await执行完了后再执行async里面await之后的代码</p>
<p> async函数由于返回的是task类型，注意属性有同步类型</p>
<ol>
<li>函数参数不能有out ref，必须返回Task<ol>
<li>不应混合使用同步和异步代码，异步最好始终异步<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static class DeadlockDemo</div><div class="line">&#123;</div><div class="line">    private static async Task DelayAsync()</div><div class="line">    &#123;</div><div class="line">        await Task.Delay(1000);</div><div class="line">    &#125;</div><div class="line">    // This method causes a deadlock when called in a GUI or ASP.NET context.</div><div class="line">    public static void Test()</div><div class="line">    &#123;</div><div class="line">        //开始延迟函数</div><div class="line">        var delayTask = DelayAsync();</div><div class="line">        // 等待延迟完成</div><div class="line">        delayTask.Wait();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//test方法在gui和aps.net会出现死锁，控制台不会</div><div class="line">//这种死锁的根本原因是 await 处理上下文的方式</div><div class="line">//默认情况下，当等待未完成的 Task 时，会捕获当前“上下文”，在 Task 完成时使用该上下文恢复方法的执行</div><div class="line">//GUI 和 ASP.NET 应用程序具有 SynchronizationContext，它每次仅允许一个代码区块运行。 </div><div class="line">//当 await 完成时，它会尝试在捕获的上下文中执行 async 方法的剩余部分。 </div><div class="line">//但是该上下文已含有一个线程，该线程在（同步）等待 async 方法完成。它们相互等待对方，从而导致死锁。</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>await不像Task.Run()，它并不会创建线程来执行，只会移交权限来继续执行。</p>
</li>
<li><p>我一开始想这玩意，不创建新线程咋个优化呢。后面他们说会挂起执行其它函数，这样并发的时候就能很好处理，不会卡住。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;async-await&quot;&gt;&lt;a href=&quot;#async-await&quot; class=&quot;headerlink&quot; title=&quot;async await&quot;&gt;&lt;/a&gt;async await&lt;/h3&gt;&lt;p&gt; 同步函数执行到async时会同步执行,当在async里遇见awai
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>JS札记——网上看的装逼写法(229)</title>
    <link href="https://xuecat.github.io/2018/01/25/229/"/>
    <id>https://xuecat.github.io/2018/01/25/229/</id>
    <published>2018-01-25T12:54:28.000Z</published>
    <updated>2018-04-23T00:34:53.822Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/229.jpg" alt=""></p>
<h3 id="JS札记"><a href="#JS札记" class="headerlink" title="JS札记"></a>JS札记</h3><p> 数字取整:<br> <code>~~</code> 其实这是个按位非的运算符做了俩次<br> <code>2.33|0</code><br> <code>2.33&gt;&gt;0</code></p>
<p> 字符转数字:<br> <code>var a =&#39;1&#39;; +a;</code> 它用隐式转换来的</p>
<p> 类型判断:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> d == <span class="string">"string"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">d <span class="keyword">instanceof</span> Person;<span class="comment">//判断constructor.prototype是否存在于要检测对象的原型链上. 所以对number string boolean无效</span></div></pre></td></tr></table></figure></p>
<p> parseInt范围:<br> <code>parseInt(0.0000008)</code>//这个结果是8, 小数点后7位出错<br> <code>parseInt(10000000000023291)</code>//20位出错</p>
<p> 数组去重:<br> <code>[...new Set([1, &quot;1&quot;, 2, 1, 1, 3])]</code></p>
<p> 指定长度填充:<br> 以前就在想了，赶紧笔记: <code>let aa = Array(6).fill(8)</code> 长度6,填充8</p>
<p> 短路表达式:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = b&amp;&amp;<span class="number">1</span>; <span class="keyword">if</span> (b) a=<span class="number">1</span>; <span class="keyword">else</span> a=b;</div><div class="line"><span class="keyword">var</span> a = b||<span class="number">1</span>; <span class="keyword">if</span> (b) a=b; <span class="keyword">else</span> a=<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p> 高逼格创建函数:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'a++; return a+1;'</span>);</div><div class="line">f(<span class="number">1</span>)<span class="comment">//3</span></div><div class="line"><span class="comment">//函数字符化</span></div></pre></td></tr></table></figure></p>
<p> 立即执行函数:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)();</div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div></pre></td></tr></table></figure></p>
<h3 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><ol>
<li>xss安全，对url和内容做过滤，防止嵌入js执行代码</li>
<li>csp, 通过服务器应答头或者html的<code>META</code>标签,限制请求源</li>
</ol>
<h3 id="浏览器Console命令"><a href="#浏览器Console命令" class="headerlink" title="浏览器Console命令"></a>浏览器Console命令</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log();</div><div class="line"><span class="built_in">console</span>.dir();<span class="comment">//显示一个对象所有属性和方法</span></div><div class="line"><span class="built_in">console</span>.dirxml();<span class="comment">//显示网页某节点所包含的html/xml</span></div><div class="line"><span class="built_in">console</span>.assert();<span class="comment">//弹框</span></div><div class="line"><span class="built_in">console</span>.trace();<span class="comment">//附带显示行数</span></div><div class="line"><span class="built_in">console</span>.time();<span class="built_in">console</span>.timeEnd();用来显示代码运行时间</div></pre></td></tr></table></figure>
<h3 id="浏览器其它"><a href="#浏览器其它" class="headerlink" title="浏览器其它"></a>浏览器其它</h3><p> 浏览器能设置条件语句断点<br> 左边可以直接启动手机模式,这样就能看手机状态下的浏览情况</p>
<h3 id="CSS黑魔法"><a href="#CSS黑魔法" class="headerlink" title="CSS黑魔法"></a>CSS黑魔法</h3><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p> 强缓存:</p>
<ul>
<li>当头的Cache-Control的max-age(最多有效时间)/s-maxage(代理最大有效时间) 被设置时, 用头的date和当前时间比对</li>
<li><p>当无 头的cache-control只有头的expires时,则用expires和当前时间对比</p>
<p>协商缓存:</p>
</li>
<li>头有last-modiied和etag,会向服务器请求是否失效,请求包加头if-modified-since和if-none-match.<br>服务器回应304浏览器就本地加载，否则重新发送数据</li>
</ul>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p> 这个属性来源于css3属性<br> 从里到外,margin-&gt;border-&gt;padding-&gt;content.</p>
<ul>
<li><p>content-box标准盒。height指content的高,width指content的宽</p>
</li>
<li><p>border-box怪异盒。height指content+padding+border的高,width指content+padding+border的高</p>
</li>
</ul>
<p>网上说在网页的顶部加上 doctype 声明。假如不加 doctype 声明，那么各个浏览器会根据自己的行为去理解网页。</p>
<h3 id="浏览器安全-1"><a href="#浏览器安全-1" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><p> CSRF(跨站点请求伪造): 用户c打开网站a，未推出a之前，打开网站b。网站b发出请求要求访问网站a，来利用未销毁的cookie来达到攻击的目的</p>
<p> 防范方法:</p>
<ul>
<li>验证http referer字段，这个字段表示http请求来源地址</li>
<li>请求接口添加token验证</li>
<li><p>http添加自定义属性</p>
<p>XSS(跨站脚本攻击):调用web接口时，提交js代码进去，下次访问页面会执行js代码达到攻击</p>
<p>防范方法:</p>
</li>
<li>输入数据编码处理(HTML Entity)</li>
<li>输入数据过滤</li>
<li>矫正</li>
</ul>
<h3 id="JS技巧"><a href="#JS技巧" class="headerlink" title="JS技巧"></a>JS技巧</h3><p><code>[]+{}</code> 非primitive type(即值类型)的<code>+</code>运算,对于数组和<code>object</code>,其实都是在调用<code>toString</code>方法.<br>数组<code>[]</code>的<code>toString</code>其实就是调用<code>.join()</code>方法.<br><code>Object</code>转<code>String</code>就是<code>[object Object]</code>(用<code>String({})</code>测试)</p>
<p><code>[]+{}</code>相当于””+”[object Object]”<br><code>{}+[]</code> 会变成俩端<code>{}</code>和<code>+[]</code>,一个代码段一个执行语句,由于后面是空且被隐式转换了,所以结果是<code>0</code><br><code>{}+{}</code></p>
<h3 id="JS有6个假值-false-null-undefined-0-“”-NaN"><a href="#JS有6个假值-false-null-undefined-0-“”-NaN" class="headerlink" title="JS有6个假值:false null undefined 0 “” NaN"></a>JS有6个假值:false null undefined 0 “” NaN</h3><p> <strong>但是它们之间并非都相等</strong><br> 以下是相等的:<br> <code>false==0</code><br> <code>false==&#39;&#39;</code><br> <code>null==undefined</code><br> <code>0==&#39;&#39;</code></p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//es5</span></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">var</span> item = a[i];</div><div class="line">    (res.indexOf(item) === <span class="number">-1</span>) &amp;&amp; res.push(item);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="浏览器渲染和服务器渲染"><a href="#浏览器渲染和服务器渲染" class="headerlink" title="浏览器渲染和服务器渲染"></a>浏览器渲染和服务器渲染</h3><p> 浏览器端渲染，指的是用js去生成html，前端做路由。举例：React, Vue等等前端框架。适合单页面应用程序。</p>
<p> 服务器端渲染，指的是用后台语言通过一些模版引擎生成html。举例：PHP文件、JSP文件、Python的Flask配合Jinja引擎、Django框架、Java配合vm模版引擎、NodeJS配合Jade。适合多页面应用。</p>
<p> <strong>浏览器渲染过程</strong><br> DOM Tree：浏览器将HTML解析成树形的数据结构。<br> CSS Rule Tree：浏览器将CSS解析成树形的数据结构。<br> Render Tree: DOM和CSSOM合并后生成Render Tree。<br> layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br> painting: 按照算出来的规则，通过显卡，把内容画到屏幕上</p>
<p> 过程是异步的，下载多少内容，构建多少render树<br> （1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染(要尽量避免它:操作dom 元素尺寸变化 css属性变化)。<br> （2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。 </p>
<p> <strong>浏览器优化</strong><br> 减少refow/repaint：</p>
<ul>
<li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</li>
<li>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的</li>
<li><p>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局</p>
<p><strong>CSS优化</strong><br>CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dom深度尽量浅</div><div class="line">减少inline javascript(<span class="keyword">script</span>嵌入那种)、css的数量</div><div class="line">不要为<span class="built_in">id</span>选择器指定类名或是标签，因为<span class="built_in">id</span>可以唯一确定一个元素</div><div class="line">避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;<span class="comment">#tp p&#123;&#125; 子选择符：#tp&gt;p&#123;&#125;</span></div><div class="line">避免使用通配符</div></pre></td></tr></table></figure>
<p><strong>js的下载和执行会阻塞Dom树的构建</strong></p>
</li>
</ul>
<h3 id="js数组"><a href="#js数组" class="headerlink" title="js数组"></a>js数组</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> tt = [<span class="string">"22"</span>, <span class="string">"55"</span>, <span class="string">"88"</span>];</div><div class="line">tt[<span class="number">7</span>] = <span class="number">3</span>;</div><div class="line">t.length<span class="comment">//8 是不是很惊讶，然而t[6]是undefined</span></div></pre></td></tr></table></figure>
<h3 id="js模块加载"><a href="#js模块加载" class="headerlink" title="js模块加载"></a>js模块加载</h3><p> commonjs:nodejs应用最多，它的require是同步的，运行时确定模块依赖关系，先加载整个模块，直接生产对象1<br> 再从对象上读取方法<br> amd:requirejs就实现了amd规范，异步，运行时加载<br> es6：编译时确定依赖关系，导出任意值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/229.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;JS札记&quot;&gt;&lt;a href=&quot;#JS札记&quot; class=&quot;headerlink&quot; title=&quot;JS札记&quot;&gt;&lt;/a&gt;JS札记&lt;/h3&gt;&lt;p&gt; 数字取整:&lt;br&gt; &lt;code&gt;~~
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="学习看书笔记" scheme="https://xuecat.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%9C%8B%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>react插件(228)</title>
    <link href="https://xuecat.github.io/2017/12/25/228/"/>
    <id>https://xuecat.github.io/2017/12/25/228/</id>
    <published>2017-12-25T15:02:02.000Z</published>
    <updated>2018-05-18T02:23:48.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-thunk"><a href="#react-thunk" class="headerlink" title="react-thunk"></a>react-thunk</h3><p> 我一开始觉得把<code>props.dispatch</code>当参数传总会异步的，但是当多个时就会分不清。</p>
<ol>
<li>只有<code>store</code>的<code>dispatch</code>后面才能跟<code>then</code>，其它都不能</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">tt</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dis</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> tt = dis(addTodo(<span class="string">'wangqiu'</span>));<span class="comment">//函数出入的参数就是dispatch，所以以次来异步发action</span></div><div class="line">    <span class="keyword">return</span> dis(toggleTodo(tt));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">   &lt;TodoList</div><div class="line">          todos=&#123;visibleTodos&#125;</div><div class="line">          onTodoClick=&#123;index =&gt;</div><div class="line">            &#123;dispatch(test(index))&#125;<span class="comment">//普遍做法如此，给dispatch传个函数进去</span></div><div class="line">          &#125; /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p> <code>https://www.w3cplus.com/javascript/immutable-js.html</code></p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p> 最近看<code>react-redux</code>,<br> <code>connect</code>中的参数有<code>mapStateToProps</code>和<code>mapDispatchToProps</code>,剩下俩个不说,<br> 他们第二个参数<code>ownProps</code>,指的是当前组件的属性<br> 它指的是<code>mapStateToProps</code>之外的属性(即通过xml属性传递的属性),state转prop后自己是能访问到的。</p>
<pre><code>connect的第二个参数,redux会给mapDispatchToProps传一个dispatch参数，拿到后可以自己做，它的返回值会被直接注入到组件的props里面。我喜欢直接返回dispatch
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mapDispatchToProps = dispatch =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">            onTodoClick: id =&gt; &#123;</div><div class="line">            dispatch(toggleTodo(id))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a>redux-actions</h4><p> createAction<br> 以前:<br> <code>const startAction = () =&gt; ({type:START})</code><br> 使用:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;createAction&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">const</span> startAction = createAction(START);</div></pre></td></tr></table></figure></p>
<p> handleactions<br> 以前:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">state=defaultState, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> START : &#123;<span class="keyword">return</span> &#123;...state, runStatus:<span class="literal">true</span>&#125;&#125;;<span class="comment">//es6的解构太方便了，会直接覆盖</span></div><div class="line">        <span class="keyword">case</span> STOP: &#123;<span class="keyword">return</span> &#123;...state, runStatus:<span class="literal">false</span>&#125;&#125;;<span class="comment">//同名属性覆盖</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 使用:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">const</span> time = handleActions(&#123;</div><div class="line">    START:(state, action) =&gt; (&#123;...state, runStatus:<span class="literal">true</span>&#125;),</div><div class="line">    STOP:(state, action) =&gt; (&#123;...state, runStatus:<span class="literal">false</span>&#125;),</div><div class="line">&#125;, defaultState);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;react-thunk&quot;&gt;&lt;a href=&quot;#react-thunk&quot; class=&quot;headerlink&quot; title=&quot;react-thunk&quot;&gt;&lt;/a&gt;react-thunk&lt;/h3&gt;&lt;p&gt; 我一开始觉得把&lt;code&gt;props.dispatch&lt;/code
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>JS继承和函数式编程的curry等(227)</title>
    <link href="https://xuecat.github.io/2017/12/18/227/"/>
    <id>https://xuecat.github.io/2017/12/18/227/</id>
    <published>2017-12-18T12:15:38.000Z</published>
    <updated>2018-01-30T14:18:53.538Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/227.jpg" alt=""></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>每个函数对象有个一个<code>prototype</code>(显式原型),指向<code>constructor</code>;但<code>constructor.prototype</code>指向本身.</li>
<li>实例只有<code>__proto__</code>(隐式原型)</li>
<li>所有实例需要共享的属性和方法,都可放在<code>prototype</code>;不需要则放在构造函数中</li>
<li>实例的<code>__proto__</code>指向构造该对象的构造函数的原型即<code>**.prototype</code></li>
</ul>
<h3 id="es5-6种继承"><a href="#es5-6种继承" class="headerlink" title="es5 6种继承"></a>es5 6种继承</h3><p><strong>来自原型对象的引用属性是所有实例共享的</strong></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>简单链</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Sub.prototype = <span class="keyword">new</span> Super();<span class="comment">//共享原型对象，arr是引用类型</span></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</div><div class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</div><div class="line"></div><div class="line"><span class="comment">//1.无法构造函数传参</span></div><div class="line">sub1.val = <span class="number">2</span>;<span class="comment">//不会影响sub2</span></div><div class="line">sub1.arr.push(<span class="number">2</span>);<span class="comment">//会影响sub2</span></div></pre></td></tr></table></figure>
<p> <strong>补充</strong><br>  对继承的简单链原理补充<br>我一直在想那样的影响为何有,今天想通了,来做点笔记</p>
<p><strong>补充:</strong> <br></p>
<ul>
<li>call: 替换上下文,可以想象成替换<code>this</code></li>
<li>new:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</div><div class="line">obj.__proto__ = Base.prototype;</div><div class="line">Base.call(obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>call</code>替换后，它还会再调用一遍<code>Base</code>函数,保证有成员变量</p>
<p><strong>过程分析:</strong><br></p>
<ul>
<li>第一行的<code>new Super</code>直接导致<code>Sub.prototype</code>拥有了<code>val</code>和<code>arr</code></li>
<li>二三行的<code>new Sub</code>只是将<code>__proto__</code>指向了<code>Sub.prototype</code></li>
</ul>
<p>所以使用<code>sub.val</code> <code>sub.arr</code>却也只是访问<code>Sub.prototype</code>上面的东西而已</p>
<p>如此说来,大家都访问一个东西却为何<code>val</code>不影响呢?<br><br>因为在第6行里是个创建而不是修改</p>
<p>第六行是对<code>sub1</code>创建一个私有属性并赋值<br>第七行是访问<code>sub1</code>的<code>arr</code>,然而没有从原型链上拿去了</p>
<ul>
<li>简单链很好,就怕某地出错,记住它们是访问一个</li>
<li>借用构造函数这个太浪费了不考虑</li>
<li>new的数量不是很多倒是可以用用组合继承</li>
</ul>
</li>
<li><p>借用构造函数</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val); <span class="comment">//1.子类互不影响 2.但是复制了父类实例属性导致内存增加 3.call不会复制原型链</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure>
</li>
<li><p>组合继承</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line"></div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//函数全放入原型中，方便共享</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val);<span class="comment">//保留传参功能</span></div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();<span class="comment">//1. 函数复用 2.构造函数传参 3.原型多余内存</span></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>寄生组合继承</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">//构建只有原型链的空对象</span></div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> proto = beget(Super.prototype);</div><div class="line">proto.constructor = Sub;</div><div class="line">Sub.prototype = proto;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();<span class="comment">//1.确实解决了以上所有问题 2.书写太麻烦了</span></div></pre></td></tr></table></figure>
</li>
<li><p>原型(感觉没意义)</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Super();</div><div class="line"><span class="keyword">var</span> sub = beget(sup);</div><div class="line">sub.v = v;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="es6继承"><a href="#es6继承" class="headerlink" title="es6继承"></a>es6继承</h3><p>上面的<code>寄生组合继承</code>同，多个<code>static</code>定义静态属性</p>
<h3 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h3><p> 这个概念是存储传入参数，够了才执行函数<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fun = a=&gt; b=&gt; c=&gt; &#123;<span class="keyword">return</span> a+b+c&#125;<span class="comment">//注意return</span></div><div class="line"><span class="keyword">let</span> fun1 = fun(<span class="number">1</span>)<span class="comment">//存储函数</span></div><div class="line"><span class="keyword">let</span> fun2 = fun1(<span class="number">2</span>);</div><div class="line"><span class="keyword">let</span> fun3 = fun2(<span class="number">3</span>);<span class="comment">//6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> fun1 = fun(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)<span class="comment">//6, 参数多了会报错</span></div></pre></td></tr></table></figure></p>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>  这个es6并没有实现，但是很多库有这个函数<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = (firstName, lastName) =&gt; <span class="string">'hello, '</span> + firstName + <span class="string">' '</span> + lastName</div><div class="line"><span class="keyword">var</span> toUpper = str =&gt; str.toUpperCase()</div><div class="line"><span class="keyword">var</span> fn = compose(toUpper, greeting)</div><div class="line"><span class="built_in">console</span>.log(fn(<span class="string">'jack'</span>, <span class="string">'smith'</span>))</div><div class="line"><span class="comment">// ‘HELLO，JACK SMITH’</span></div></pre></td></tr></table></figure></p>
<ul>
<li>compose的参数是函数，返回的也是一个函数</li>
<li>因为除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的</li>
<li>compsoe函数可以接受任意的参数，所有的参数都是函数，且执行方向是自右向左的，初始函数一定放到参数的最右面</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/227.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个函数对象有个一个&lt;code&gt;p
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="学习看书笔记" scheme="https://xuecat.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%9C%8B%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++11左右值 (226)</title>
    <link href="https://xuecat.github.io/2017/12/18/226/"/>
    <id>https://xuecat.github.io/2017/12/18/226/</id>
    <published>2017-12-18T12:15:38.000Z</published>
    <updated>2017-12-20T15:09:39.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-左右值"><a href="#C-左右值" class="headerlink" title="C++左右值"></a>C++左右值</h3><p> 左值指即能出现等号左边，也能出现在右边的变量（通常指有变量名的值）<br> 右值值只能出现等号右边的值（通常指无变量名的值，函数返回和表达式，常量——不跟对象关联的常量）<br> c++11在上面右值多个将亡值<br><code>move</code>右转左 <code>forward</code>左转右</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyClass <span class="title">fun</span> <span class="params">()</span> </span>&#123;MyClass <span class="keyword">return</span> s;&#125;</div><div class="line">MyClass s= fun();</div><div class="line">MyClass&amp; s = fun();</div><div class="line">MyClass&amp;&amp; s = fun();<span class="comment">//这三个全是调用移动构造函数</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C-左右值&quot;&gt;&lt;a href=&quot;#C-左右值&quot; class=&quot;headerlink&quot; title=&quot;C++左右值&quot;&gt;&lt;/a&gt;C++左右值&lt;/h3&gt;&lt;p&gt; 左值指即能出现等号左边，也能出现在右边的变量（通常指有变量名的值）&lt;br&gt; 右值值只能出现等号右边的值（通常指
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++函数指针模板又一次说明(225)</title>
    <link href="https://xuecat.github.io/2017/10/26/225/"/>
    <id>https://xuecat.github.io/2017/10/26/225/</id>
    <published>2017-10-26T15:50:30.000Z</published>
    <updated>2017-11-13T13:15:50.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/225.jpg" alt=""></p>
<h3 id="函数指针又一次说明"><a href="#函数指针又一次说明" class="headerlink" title="函数指针又一次说明"></a>函数指针又一次说明</h3><p>今天看rapidjson的源码，看到一句默认操作符转换函数指针的代码懵逼了居然。。<br>好歹也是读了十来本c++的书了，还这么2。<br>顺便做笔记。</p>
<ul>
<li>按照effictive说法，结构体比函数指针快。所以用<code>operator()</code>代替函数指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我按照它代码的写法，尝试了下。感觉默认指针函数只能用在if语句上来走个默认转换</span></div><div class="line"><span class="keyword">struct</span> Prs &#123;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(Prs::*Boolt)</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">bool</span> m_bR;</div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Boolt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !IsEr() ? &amp;Prs::IsEr : <span class="literal">NULL</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsEr</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> m_bR == <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ah</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Prs &amp;f, Prs::Boolt df)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> ((f.*df)())</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> a-b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Prs d;</div><div class="line">d.m_bR = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (d)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> f = ah(<span class="number">1</span>, <span class="number">2</span>, d, d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用函数指针这个看上去没有创建对象，其实是初始化了一个临时对象再来调用它的operator()函数</span></div><div class="line"><span class="comment">//感觉用这个方法方便点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> TP&gt;</div><div class="line"><span class="keyword">struct</span> PrsT &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function">TR <span class="title">operator</span><span class="params">()</span> <span class="params">(TP a, TP b)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a+b;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> TP, <span class="keyword">typename</span> Fun&gt;</div><div class="line"><span class="function">TR <span class="title">aht</span><span class="params">(TR a, TP b, Fun f)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> f(a, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Prs &#123;</div><div class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(Prs::*Boolt)</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">bool</span> m_bR;</div><div class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Boolt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> !IsEr() ? &amp;Prs::IsEr : <span class="literal">NULL</span>;</div><div class="line">	&#125;;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsEr</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> m_bR == <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> ff = aht(<span class="number">1</span>, <span class="number">2</span>, PrsT&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/225.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数指针又一次说明&quot;&gt;&lt;a href=&quot;#函数指针又一次说明&quot; class=&quot;headerlink&quot; title=&quot;函数指针又一次说明&quot;&gt;&lt;/a&gt;函数指针又一次说明&lt;/h3&gt;&lt;p
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="指针" scheme="https://xuecat.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>React再次学习(224)</title>
    <link href="https://xuecat.github.io/2017/08/29/224/"/>
    <id>https://xuecat.github.io/2017/08/29/224/</id>
    <published>2017-08-29T13:45:08.000Z</published>
    <updated>2017-11-13T13:15:58.535Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/224.jpg" alt=""></p>
<h3 id="ref的使用"><a href="#ref的使用" class="headerlink" title="ref的使用"></a>ref的使用</h3><p>这是react对<code>render</code>中元素提供的一个属性，专门用来标志<code>mount</code>后的元素<br>这个回调属性会在组件安装后立即执行。</p>
<h4 id="ref字符"><a href="#ref字符" class="headerlink" title="ref字符"></a>ref字符</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"theInput"</span>/&gt;</span> //通过这个属性来对一个dom设置标志符</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React.findDOMNode(<span class="keyword">this</span>.refs.theInput).focus();<span class="comment">//再通过这个方法来达到访问实体化dom的效果</span></div></pre></td></tr></table></figure>
<h4 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h4><p>当它作为函数时，默认参数就是一个dom的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TextInput</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span> =&gt;</span> this._input = c&#125; /&gt;;//由于安装后立即执行，能得到对象</span></div><div class="line">&#125;,</div><div class="line">componentDidMount: function() &#123;</div><div class="line">   this._input.focus();//对对象操作</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="bind和this"><a href="#bind和this" class="headerlink" title="bind和this"></a>bind和this</h3><p> 官方文档中react用bind很多;<br> 但看他们喜欢在构造函数如此： this.handleToggleClick = this.handleToggleClick.bind(this)</p>
<p> 我喜欢用箭头函数(es6特性，this指向定义处)直接调用</p>
<h3 id="JSX嵌入"><a href="#JSX嵌入" class="headerlink" title="JSX嵌入"></a>JSX嵌入</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//jsx嵌入任何表达式</div><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;Hello!&lt;/h1&gt;</div><div class="line">  &#123;unreadMessages.length &gt; 0 &amp;&amp;</div><div class="line">    &lt;h2&gt;</div><div class="line">      You have &#123;unreadMessages.length&#125; unread messages.</div><div class="line">    &lt;/h2&gt;</div><div class="line">  &#125;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">//三目运算符</div><div class="line">&lt;div&gt;</div><div class="line">  The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in.</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> components = &#123;</div><div class="line">  photo: PhotoStory,</div><div class="line">  video: VideoStory</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="comment">// Correct! JSX type can be a capitalized variable.</span></div><div class="line">  <span class="keyword">const</span> SpecificStory = components[props.storyType];</div><div class="line">  <span class="keyword">return</span> &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//默认值</div><div class="line">&lt;MyTextBox autocomplete /&gt;//它会默认传true的，但是官方建议不要这么写</div><div class="line"></div><div class="line">//利用es6的解构</div><div class="line">function App1() &#123;</div><div class="line">  return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function App2() &#123;</div><div class="line">  const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;;</div><div class="line">  return &lt;Greeting &#123;...props&#125; /&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="html不接受字符"><a href="#html不接受字符" class="headerlink" title="html不接受字符"></a>html不接受字符</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//有以下俩种方式解决</span></div><div class="line">&lt;MyComponent message=<span class="string">"&amp;lt;3"</span> /&gt;</div><div class="line"></div><div class="line">&lt;MyComponent message=&#123;'&lt;3'&#125; /&gt;</div></pre></td></tr></table></figure>
<h4 id="jsx插入函数"><a href="#jsx插入函数" class="headerlink" title="jsx插入函数"></a>jsx插入函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这种用法太牛逼了，虽然不多见</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Repeat</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> items = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.numTimes; i++) &#123;</div><div class="line">    items.push(props.children(i));<span class="comment">//这里直接调用父类定义的函数，一个一个执行添加</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;items&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListOfTenThings</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Repeat</span> <span class="attr">numTimes</span>=<span class="string">&#123;10&#125;</span>&gt;</span></span></div><div class="line">      &#123;(index) =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>This is item &#123;index&#125; in the list<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">Repeat</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="react-map组件时"><a href="#react-map组件时" class="headerlink" title="react map组件时"></a>react map组件时</h3><ul>
<li>一个元素的key最好是这个元素在<strong>列表</strong>中拥有的一个独一无二的字符串(所以不同数组列表可以用相同key)</li>
<li>元素的key只有在它和它的兄弟节点对比时才有意义(换句话说必须在map函数里面的组件里)</li>
<li>key只对react可见，要用其值，请将作为属性再加个传入</li>
</ul>
<h3 id="计算属性名"><a href="#计算属性名" class="headerlink" title="计算属性名"></a>计算属性名</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多了个name属性，来对应绑定属性</span></div><div class="line"><span class="comment">//通过</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;[name]: value&#125;);</div><div class="line"><span class="comment">//等同于如下</span></div><div class="line"><span class="keyword">var</span> partState = &#123;&#125;;</div><div class="line">partState[name] = value;</div><div class="line"><span class="keyword">this</span>.setState(partState);</div></pre></td></tr></table></figure>
<h3 id="控制多个元素"><a href="#控制多个元素" class="headerlink" title="控制多个元素"></a>控制多个元素</h3><p> 这个是看了官方的例子，感觉太好用了，笔记下来</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      isGoing: <span class="literal">true</span>,</div><div class="line">      numberOfGuests: <span class="number">2</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.handleInputChange = <span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handleInputChange(event) &#123;</div><div class="line">    <span class="keyword">const</span> target = event.target;</div><div class="line">    <span class="keyword">const</span> value = target.type === <span class="string">'checkbox'</span> ? target.checked : target.value;</div><div class="line">    <span class="keyword">const</span> name = target.name;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      [name]: value</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;form&gt;</div><div class="line">        &lt;label&gt;</div><div class="line">          Is going:</div><div class="line">          &lt;input</div><div class="line">            name="isGoing"</div><div class="line">            type="checkbox"</div><div class="line">            checked=&#123;this.state.isGoing&#125;</div><div class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</div><div class="line">        &lt;/label&gt;</div><div class="line">        &lt;br /&gt;</div><div class="line">        &lt;label&gt;</div><div class="line">          Number of guests:</div><div class="line">          &lt;input</div><div class="line">            name="numberOfGuests"</div><div class="line">            type="number"</div><div class="line">            value=&#123;this.state.numberOfGuests&#125;</div><div class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</div><div class="line">        &lt;/label&gt;</div><div class="line">      &lt;/form&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ref用于子组件"><a href="#ref用于子组件" class="headerlink" title="ref用于子组件"></a>ref用于子组件</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Parent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;CustomTextInput</div><div class="line">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</div><div class="line">      /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="突变数据"><a href="#突变数据" class="headerlink" title="突变数据"></a>突变数据</h3><p> 通过<code>shouldComponentUpdate</code>来判断是否渲染组件，有个<code>React.PureComponent</code>可提供继承，它默认填写了<code>shouldComponentUpdate</code>函数，但是里面只是一些浅比较(对像就算被添加属性,对象的地址还是没变,导致比较为true);<br> 深层数据则不行。<br> 所以官方建议是<code>Immutable</code>来配合使用</p>
<h3 id="老式的创建类和es6创建类"><a href="#老式的创建类和es6创建类" class="headerlink" title="老式的创建类和es6创建类"></a>老式的创建类和es6创建类</h3><p> <a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="external">https://reactjs.org/docs/react-without-es6.html</a></p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p> 这个特性在官方网站上被说明为不建议使用.<br> 优点:<br>  跨越组件层次传递，这简直太好了，不用像<code>props</code>那样一个一个传，直接跨代传都可以<br> 缺点:<br>  这也是官方举例，当state或者setState 被调用,getChildContext也会被调用,生成新的context;<br>  但<code>shouldComponentUpdate</code>返回的 false 会 block 住 context，导致没有更新</p>
<p>  另外context相当一个全局变量，难以追溯修改源.</p>
<p> 虽然官方不建议用，但看网上建议把它当个全局固定值用，避免修改来躲避状态更新失败.</p>
<h3 id="protals"><a href="#protals" class="headerlink" title="protals"></a>protals</h3><p> 当组件需要”跳出”容器(对话框,提示框,<code>overflow:hidden</code> <code>z-index</code>等),此时使用此属性</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/224.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;ref的使用&quot;&gt;&lt;a href=&quot;#ref的使用&quot; class=&quot;headerlink&quot; title=&quot;ref的使用&quot;&gt;&lt;/a&gt;ref的使用&lt;/h3&gt;&lt;p&gt;这是react对&lt;co
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>js的数组(223)</title>
    <link href="https://xuecat.github.io/2017/07/17/223/"/>
    <id>https://xuecat.github.io/2017/07/17/223/</id>
    <published>2017-07-17T15:44:03.000Z</published>
    <updated>2017-11-13T13:16:05.746Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript中的数组对象是一种伪数组的”Array-like”对象，“它把数组的下标转变成字符串，用其作为属性”。<br>声明一个数组：<br>var arr=[1,2,3];<br>然后使用“负索引”<br>arr[-0.5]=100;<br>实际上arr.length值仍然是3，不过arr得到一个键值对为-0.5:100的属性，虽然不能使用小数点取这个属性和值，但方括号是可以用的 arr[-0.5]或arr[‘-0.5’]都可以得到100</p>
<p><code>负数和字符并不影响长度</code><br>数组对象其实是一个特殊对象，他拥有普通对象的全部特性，所以不止负索引，小数索引，连字符串索引都是可以的，只是用这些索引向数组添加属性时，数组的length不会增加罢了，而只有当索引是正整数或其对应数字串时，length才会增加，仅此而已。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript中的数组对象是一种伪数组的”Array-like”对象，“它把数组的下标转变成字符串，用其作为属性”。&lt;br&gt;声明一个数组：&lt;br&gt;var arr=[1,2,3];&lt;br&gt;然后使用“负索引”&lt;br&gt;arr[-0.5]=100;&lt;br&gt;实际上arr.len
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>js this/原型/pro(222)</title>
    <link href="https://xuecat.github.io/2017/06/06/222/"/>
    <id>https://xuecat.github.io/2017/06/06/222/</id>
    <published>2017-06-06T13:46:30.000Z</published>
    <updated>2018-03-26T04:25:15.414Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/222.jpg" alt=""></p>
<p>今天看一代码把以前的知识又忘了，现专门记下笔记</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>this的上下文环境永远在被调用函数的上下文环境</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var someuser = &#123; </div><div class="line">    name: <span class="string">'byvoid'</span>, </div><div class="line">    <span class="function"><span class="keyword">func</span>: <span class="title">function</span><span class="params">()</span> &#123;</span></div><div class="line">        console.<span class="built_in">log</span>(this.name)<span class="comment">; </span></div><div class="line">    &#125;</div><div class="line">&#125;<span class="comment">; </span></div><div class="line">var foo = &#123; </div><div class="line">    name: <span class="string">'foobar'</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"> </div><div class="line">someuser.<span class="keyword">func</span>()<span class="comment">; // 输出 byvoid (被调用函数func的上下文是someuser)</span></div><div class="line"> </div><div class="line">foo.<span class="keyword">func</span> = someuser.<span class="keyword">func</span><span class="comment">; </span></div><div class="line">foo.<span class="keyword">func</span>()<span class="comment">; // 输出 foobar (被调用函数func的上下文是foo)</span></div><div class="line"> </div><div class="line">name = <span class="string">'global'</span><span class="comment">;</span></div><div class="line"><span class="function"><span class="keyword">func</span> = <span class="title">someuser</span>.<span class="title">func</span>; </span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span>; // 输出 <span class="title">global</span> <span class="params">(被调用函数fuc的上下文是全局)</span></span></div></pre></td></tr></table></figure>
<h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><p>lamda不同，它是在哪被定义，this的上下文就是被定义的地方<br>就算是嵌套箭头，也没有this上下文，默认最外层的上下文</p>
<p>由于没有自己的this，所以bind call等函数也无效 </p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>js对象分俩种：普通对象和函数对象<br>函数对象： 函数的定义，匿名函数的赋值<br>普通对象：数组，结构体，new function()</p>
<p>一个函数对象可以访问到<code>prototype</code> <code>__proto__</code><br>普通对象只能访问到<code>__proto__</code></p>
<p><code>__proto__</code>指向构造函数的<code>prototype</code>,这形成了原型链(也是es5的继承，属性的访问当prototype没有就会通过<code>__proto__</code>去上级寻找)<br>所以函数对象的<code>__proto__</code>指向的是原型的<code>prototype</code></p>
<p><code>prototype</code>的来源: 1.原型的继承 2.自定义的赋值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/222.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天看一代码把以前的知识又忘了，现专门记下笔记&lt;/p&gt;
&lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>WebApi(221)</title>
    <link href="https://xuecat.github.io/2017/04/19/221/"/>
    <id>https://xuecat.github.io/2017/04/19/221/</id>
    <published>2017-04-19T14:36:36.000Z</published>
    <updated>2017-06-06T13:53:08.303Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/221.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>webvideo本地枚举文件太恶心了，算了写个服务器来读吧，顺便把avi和rmvb解包写了.</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>这里的Controller继承于ApiController,</li>
<li>IE和Firefox发送了不同的Accept报头,导致返回的数据可以是JSON，也可以是XML（感觉太强大了，这都做好了。客户端请求的“application/json”中的Accept报头）</li>
</ul>
<p>路由：<code>/api/{controller}/{id}</code> 在<code>id = RouteParameter.Optional</code>情况下<br>controller匹配控制器名<br>{id} 匹配名称为id的方法参数（即函数的参数名叫id）</p>
<p><code>/api/products</code> <code>products</code>匹配名为ProductsController的控制器。该请求是一个GET请求，因此框架在ProductsController上查找一个名称以<code>GET…</code>开头的方法。</p>
<p>进一步地，这个URI不包含可选的{id}片段，因此，框架查找的是一个不带参数的方法。于是，ProductsController::GetAllProducts满足所有这些需求</p>
<p><strong>同理</strong> 如果是个<code>POST``Put</code>请求，会去找<code>POST``Put</code>开头的方法 以及<code>Delete</code></p>
<p><code>/api/products/1</code> 找到参数名叫id的函数，并把这个传入。<br><strong>同理</strong> <code>/api/products/abc</code>就不行，因为只有GetProductById有个叫id的参数，但是是int，无法转换为string</p>
<p><strong>Post</strong><br>js和c#的完美兼容，直接互相传对象，完全可以解析<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> response = Request.CreateResponse&lt;Product&gt;(HttpStatusCode.Created, item); </div><div class="line"><span class="built_in">string</span> uri = Url.<span class="keyword">Link</span>(<span class="string">"DefaultApi"</span>, <span class="literal">new</span> &#123; id = item.Id &#125;); <span class="comment">//当服务器创建一个资源时，它应当在响应的Location报头中包含新资源的URI。</span></div><div class="line">response.Headers.Location = <span class="literal">new</span> Uri(uri);</div></pre></td></tr></table></figure></p>
<h3 id="WebapiClient"><a href="#WebapiClient" class="headerlink" title="WebapiClient"></a>WebapiClient</h3><p>添加库，用<code>HttpClient</code>设置base uri，设置请求报头。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">HttpResponseMessage response = client.GetAsync(<span class="string">"api/products"</span>).Result;  <span class="comment">// Blocking call（阻塞调用）! </span></div><div class="line"><span class="keyword">if</span> (response.IsSuccessStatusCode) </div><div class="line">&#123; </div><div class="line">    <span class="comment">// Parse the response body. Blocking!</span></div><div class="line">    <span class="comment">// 解析响应体。阻塞！</span></div><div class="line">    <span class="keyword">var</span> products = response.Content.ReadAsAsync&lt;IEnumerable&lt;Product&gt;&gt;().Result; </div><div class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> p <span class="keyword">in</span> products) </div><div class="line">    &#123; </div><div class="line">        Console.WriteLine(<span class="string">"&#123;0&#125;\t&#123;1&#125;;\t&#123;2&#125;"</span>, p.Name, p.Price, p.Category); </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//异步和阻塞注意</span></div><div class="line"><span class="comment">//自动构造结构数据很智能：比如Product有个属性和服务器的不对应，那那个属性将不被赋值，只赋值对应的属性</span></div><div class="line"></div><div class="line">---</div><div class="line"><span class="comment">//post的时候</span></div><div class="line"><span class="comment">// 创建JSON格式化器。</span></div><div class="line">MediaTypeFormatter jsonFormatter = <span class="keyword">new</span> JsonMediaTypeFormatter(); </div><div class="line"></div><div class="line"><span class="comment">// Use the JSON formatter to create the content of the request body.</span></div><div class="line"><span class="comment">// 使用JSON格式化器创建请求体内容。</span></div><div class="line">HttpContent content = <span class="keyword">new</span> ObjectContent&lt;Product&gt;(product, jsonFormatter); </div><div class="line"></div><div class="line"><span class="comment">// Send the request.</span></div><div class="line"><span class="comment">// 发送请求。</span></div><div class="line"><span class="keyword">var</span> resp = client.PostAsync(<span class="string">"api/products"</span>, content).Result;</div><div class="line"><span class="comment">//或者client.PostAsJsonAsync("api/products", gizmo).Result;</span></div></pre></td></tr></table></figure></p>
<p>上面讲了<code>client.GetAsync(&quot;api/products&quot;).Result</code> 是阻塞函数，并不会把控制返回给调用者，这导致一直阻塞（ui线程阻塞）。<br>给出2个解决方法：</p>
<ol>
<li><p><code>async</code>和<code>await</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">GetProducts</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>) </span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">try</span> </div><div class="line">    &#123; </div><div class="line">        btnGetProducts.IsEnabled = <span class="literal">false</span>; </div><div class="line"></div><div class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"api/products"</span>); </div><div class="line">        response.EnsureSuccessStatusCode(); <span class="comment">// Throw on error code（有错误码时报出异常）.</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> products = <span class="keyword">await</span> response.Content.ReadAsAsync&lt;IEnumerable&lt;Product&gt;&gt;(); </div><div class="line">        _products.CopyFrom(products); </div><div class="line"></div><div class="line">    &#125; </div><div class="line">    <span class="keyword">catch</span> (Newtonsoft.Json.JsonException jEx) </div><div class="line">    &#123; </div><div class="line">        <span class="comment">// This exception indicates a problem deserializing the request body.</span></div><div class="line">        <span class="comment">// 这个异常指明了一个解序列化请求体的问题。</span></div><div class="line">        MessageBox.Show(jEx.Message); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">catch</span> (HttpRequestException ex) </div><div class="line">    &#123; </div><div class="line">        MessageBox.Show(ex.Message); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">finally</span> </div><div class="line">    &#123; </div><div class="line">        btnGetProducts.IsEnabled = <span class="literal">true</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>安装<code>Async Targeting Pack</code> </p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">client.GetAsync(<span class="string">"api/products/2"</span>).ContinueWith((t) =&gt; </div><div class="line">    &#123; </div><div class="line">        if (t.IsFaulted) </div><div class="line">        &#123; </div><div class="line">            MessageBox.<span class="keyword">Show(t.Exception.Message); </span></div><div class="line">            <span class="keyword">btnGetProducts.IsEnabled </span>= true<span class="comment">; </span></div><div class="line">        &#125; </div><div class="line">        else </div><div class="line">        &#123; </div><div class="line">            var response = t.Result<span class="comment">; </span></div><div class="line">            if (response.IsSuccessStatusCode) </div><div class="line">            &#123; </div><div class="line">                response.Content.ReadAsAsync&lt;IEnumerable&lt;Product&gt;&gt;(). </div><div class="line">                    ContinueWith(<span class="built_in">t2</span> =&gt; </div><div class="line">                        &#123; </div><div class="line">                            if (<span class="built_in">t2</span>.IsFaulted) </div><div class="line">                            &#123; </div><div class="line">                                MessageBox.<span class="keyword">Show(t2.Exception.Message); </span></div><div class="line">                                <span class="keyword">btnGetProducts.IsEnabled </span>= true<span class="comment">; </span></div><div class="line">                            &#125; </div><div class="line">                            else </div><div class="line">                            &#123; </div><div class="line">                                var products = <span class="built_in">t2</span>.Result<span class="comment">; </span></div><div class="line">                                _products.CopyFrom(products)<span class="comment">; </span></div><div class="line">                                <span class="keyword">btnGetProducts.IsEnabled </span>= true<span class="comment">; </span></div><div class="line">                            &#125; </div><div class="line">                        &#125;, TaskScheduler.FromCurrentSynchronizationContext())<span class="comment">; </span></div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125;, TaskScheduler.FromCurrentSynchronizationContext())<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HttpClient消息处理器"><a href="#HttpClient消息处理器" class="headerlink" title="HttpClient消息处理器"></a>HttpClient消息处理器</h3><p>通过这个我可以把自定义的头处理掉</p>
<h3 id="路由变异"><a href="#路由变异" class="headerlink" title="路由变异"></a>路由变异</h3><p><code>id = RouteParameter.Optional</code>情况下</p>
<p>当路由为 <code>api/{controller}/{action}/{id}</code> 时，<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductsController</span> : <span class="title">ApiController</span> </div><div class="line">&#123; </div><div class="line">    [HttpGet] <span class="comment">//需要显式的指定映射</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Details</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>; <span class="comment">//api/products/details/1</span></div><div class="line"></div><div class="line">    [HttpPost] </div><div class="line">    [ActionName(<span class="string">"Thumbnail"</span>)] <span class="comment">//覆盖动作，这样就转到api/products/thumbnail/id</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddThumbnailImage</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//除此外还有个： [NonAction]属性可以修饰动作，这样框架就不会映射到那个函数</span></div><div class="line"><span class="comment">//[AcceptVerbs("GET", "HEAD")] 允许此方法对get和head的http方法（put/delete等同理）</span></div></pre></td></tr></table></figure></p>
<p>###　异常处理<br>总而言之（exception和error都用最好）：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="keyword">string</span>.Format(<span class="string">"Product with id = 0 not found"</span>);</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpResponseException(</div><div class="line">    Request.CreateErrorResponse(HttpStatusCode.NotFound, message));</div></pre></td></tr></table></figure></p>
<h3 id="自定义消息过滤"><a href="#自定义消息过滤" class="headerlink" title="自定义消息过滤"></a>自定义消息过滤</h3><p>这个要继承<code>DelegatingHandler</code>,服务器在config.MessageHandlers加，客户端在HttpClient加。</p>
<p>唯一的注意http头的加法，客户端随便加，服务器一般如此<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">return</span> <span class="selector-tag">base</span><span class="selector-class">.SendAsync</span>(request, cancellationToken)</div><div class="line"><span class="selector-class">.ContinueWith</span>( (task) =&gt; &#123;</div><div class="line">    HttpResponseMessage response = task<span class="selector-class">.Result</span>;</div><div class="line">    response<span class="selector-class">.Headers</span><span class="selector-class">.Add</span>(_header, <span class="string">"Server"</span>);</div><div class="line">    return response;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Post数据"><a href="#Post数据" class="headerlink" title="Post数据"></a>Post数据</h3><p>有俩种，复合类型和简单类型</p>
<ul>
<li>复合类型(传和接受都是自定义的结构体)</li>
</ul>
<p>服务器对对这类型没啥要求，传入参数是自定义类或结构体就好。</p>
<p>客户端代码必须传<code>application/json</code>格式数据(我用postman测试了下，选raw，传json字符串可以的)</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string <span class="attr">seri</span> = JsonConvert.SerializeObject(</div><div class="line">                new Product &#123; <span class="attr">Id</span> = <span class="number">1</span>, <span class="attr">Name</span> = <span class="string">"Tomato Soup"</span>, <span class="attr">Category</span> = <span class="string">"Groceries"</span> &#125;);</div><div class="line">HttpResponseMessage <span class="attr">response</span> = client.PostAsync(</div><div class="line">    <span class="string">"api/products/PostPro1/"</span></div><div class="line">    , new StringContent(seri, </div><div class="line">    Encoding.Unicode, <span class="string">"application/json"</span>)).Result;</div></pre></td></tr></table></figure>
<ul>
<li>简单类型(服务器接收的是string int这种类型)</li>
</ul>
<p>服务器要求用<code>[FromBody]</code>修饰参数</p>
<p>客户端要求发送<code>=value</code>的数据（代码和测试真心发俩种数据）</p>
<p>客户端代码,不知道为何必须用<code>{ &quot;&quot;: [&quot;update one&quot;, &quot;update two&quot;, &quot;update three&quot;] }</code>格式数据 且<code>x-www-form-urlencoded</code>它才认同</p>
<p>ajax只需要传上面的格式就好了<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> conte = <span class="keyword">new</span> FormUrlEncodedContent(</div><div class="line">    <span class="keyword">new</span>[]</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">new</span> KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;(<span class="string">""</span>, <span class="string">"login"</span>)</div><div class="line">    &#125;</div><div class="line">    );</div><div class="line">HttpResponseMessage response = client.PostAsync(</div><div class="line">    <span class="string">"api/products/PostPro1/"</span></div><div class="line">    , conte).Result;</div></pre></td></tr></table></figure></p>
<p>然而我用<code>postman</code>选<code>raw</code>，传<code>=rety</code>就可以传入<code>rety</code>字符进去。<br><strong>angular的js没试过，放以后把</strong> </p>
<h3 id="Upload-Form-Data"><a href="#Upload-Form-Data" class="headerlink" title="Upload Form Data"></a>Upload Form Data</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;HttpResponseMessage&gt; <span class="title">PostFormData</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!Request.Content.IsMimeMultipartContent())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpResponseException(</div><div class="line">            System.Net.HttpStatusCode.UnsupportedMediaType</div><div class="line">            );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">string</span> root = HttpContext.Current.Server.MapPath(<span class="string">"~/App_Data"</span>);</div><div class="line">    <span class="keyword">var</span> provider = <span class="keyword">new</span> MultipartFormDataStreamProvider(root);</div><div class="line"></div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">await</span> Request.Content.ReadAsMultipartAsync(provider);<span class="comment">//读取后，会自动在根目录保存临时文件</span></div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> (MultipartFileData file <span class="keyword">in</span> provider.FileData)</div><div class="line">        &#123;</div><div class="line">            Trace.WriteLine(file.Headers.ContentDisposition.FileName);</div><div class="line">            Trace.WriteLine(<span class="string">"Server file path: "</span> + file.LocalFileName);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> key <span class="keyword">in</span> provider.FormData.AllKeys)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> val <span class="keyword">in</span> provider.FormData.GetValues(key))</div><div class="line">            &#123;</div><div class="line">                Trace.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;: &#123;1&#125;"</span>, key, val));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        HttpContext.Current.Request.Files[<span class="number">0</span>].SaveAs(root+<span class="string">"//webservertt.txt"</span>);<span class="comment">//重新按文件名保存</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> Request.CreateResponse(HttpStatusCode.OK);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (System.Exception e)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> Request.CreateErrorResponse(HttpStatusCode.InternalServerError, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="限制数据"><a href="#限制数据" class="headerlink" title="限制数据"></a>限制数据</h3><p>如下对结构进行限制<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line"></div><div class="line">    [Required]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line"></div><div class="line">    [Range(<span class="number">0</span>,<span class="number">999</span>)]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Weight &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//当webapi对一复合类型进行自动转换时，可以用此来判断结构体是否符合限制</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpResponseMessage <span class="title">Post</span>(<span class="params">Product product</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (ModelState.IsValid)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do something with the product (not shown).</span></div><div class="line">        <span class="comment">// 用product做一些事（未表示出来）</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpResponseMessage(HttpStatusCode.OK);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpResponseMessage(HttpStatusCode.BadRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Under-Posting和Over-Posting"><a href="#Under-Posting和Over-Posting" class="headerlink" title="Under-Posting和Over-Posting"></a>Under-Posting和Over-Posting</h3><p><code>Under-Posting</code> 当客户端提交时遗漏某些属性，json格式化器会默认给缺失赋值（0）<br><code>Over-Posting</code> 当客户端提交时属性过多时，格式化器会忽略多余的属性</p>
<h3 id="NuGet和Self-Host"><a href="#NuGet和Self-Host" class="headerlink" title="NuGet和Self-Host"></a>NuGet和Self-Host</h3><ol>
<li><code>Microsoft.AspNet.WebApi.OwinSelfHost</code>是自驻留服务安装的</li>
<li>controller接口一定要<code>public</code>，这个搞了我好久哦。</li>
</ol>
<p>单个webapi自己的话(<code>weapi.core</code>是必须的)，要加<code>Microsoft.AspNet.WebApi.WebHost</code><br>这个模式下直接用<code>Global.asax</code>做入口是可以的.(遇见403不怕，只是页面没添加，api接口还是好的)</p>
<p>后来翻资料，还有其它方法可以用<code>Microsoft.Owin.Host.SystemWeb and Microsoft.AspNet.WebApi.Owin</code>;建立<code>Startup</code>入口是可以的。<br>(完全想不明白，为何俩台电脑反应如此不同)</p>
<p>self的要加<code>Microsoft.AspNet.WebApi.OwinSelfHost</code> (这个官方介绍是有俩种方式的，我个人喜欢用owin)<br><code>xcopy /y &quot;$(TargetDir)$(ProjectName).*&quot; &quot;$(ProjectDir)\..\WebHostServerC\bin\Debug&quot;</code></p>
<h4 id="content-root和web-root"><a href="#content-root和web-root" class="headerlink" title="content root和web root"></a>content root和web root</h4><p>要用content root要安装<code>Microsoft.AspNetCore.StaticFiles</code> (<code>Microsoft.AspNetCore.Hosting</code>里面有PhysicalFileProviderd的类)</p>
<h3 id="路由属性和重定向"><a href="#路由属性和重定向" class="headerlink" title="路由属性和重定向"></a>路由属性和重定向</h3><p>一直看他们用<code>Route</code>和<code>RoutePrefix</code>来指定路由,发现调用 <code>MapHttpAttributeRoutes</code>就可以使用了。</p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2" target="_blank" rel="external">https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2</a></p>
<p>路由属性的好处是，可以使用匹配路由([Route(“~/api/authors/{authorId:int}/books”)]public IEnumerable<book> GetByAuthor(int authorId) { … })和父路由</book></p>
<p>先把重定向代码贴了。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>[Route(<span class="string">""</span>), HttpGet]</div><div class="line"><span class="regexp">//</span>[ApiExplorerSettings(IgnoreApi = true)]</div><div class="line"><span class="regexp">//</span>public HttpResponseMessage RedirectToSwaggerUi()</div><div class="line"><span class="regexp">//</span>&#123;</div><div class="line"><span class="regexp">//</span>    var httpResponseMessage = new HttpResponseMessage(HttpStatusCode.Found);</div><div class="line"><span class="regexp">//</span>    httpResponseMessage.Headers.Location = new Uri(<span class="string">"/app"</span>, UriKind.Relative);</div><div class="line"><span class="regexp">//</span>    return httpResponseMessage;</div><div class="line"><span class="regexp">//</span>&#125;</div></pre></td></tr></table></figure></p>
<h3 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h3><p><code>Microsoft.Owin.StaticFiles</code><br><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files" target="_blank" rel="external">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="Asp.Net" scheme="https://xuecat.github.io/tags/Asp-Net/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap(218)</title>
    <link href="https://xuecat.github.io/2017/03/22/218/"/>
    <id>https://xuecat.github.io/2017/03/22/218/</id>
    <published>2017-03-22T13:56:53.000Z</published>
    <updated>2017-05-22T15:58:18.580Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/218.jpg" alt=""></p>
<p>bootstrap语法太丰富了，完全可以把很多js代码去掉。所以记录下来</p>
<p><a href="http://v3.bootcss.com/components/" target="_blank" rel="external">http://v3.bootcss.com/components/</a><br><a href="http://getbootstrap.com/javascript/#modals-examples" target="_blank" rel="external">http://getbootstrap.com/javascript/#modals-examples</a></p>
<h3 id="ui-bootstrap"><a href="#ui-bootstrap" class="headerlink" title="ui-bootstrap"></a>ui-bootstrap</h3><p>bootstrap的TPLS版本里面有所有组件的html代码.angular最好用这个.<br>然后对于angular使用的是ui-boostrap，这个只是定义了控件，还是要去bootstrap官网去下载bootstrap的源码来。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>它主要是自己的<code>data</code>语法太多了:</p>
<ul>
<li><p><code>data-dismiss=&quot;modal&quot;</code> 如果在<code>modal</code>弹窗加上，那么点击则会关闭弹窗</p>
</li>
<li><p><code>data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;</code>  这样点击按钮就会弹出<code>modal</code>窗口，由于<code>data-target</code>具有css的选择器功能(<code>#id</code>也可以)，所以选择的是class为bs-exampl-modal-lg的元素。</p>
<p>  如：<code>&lt;div class=&quot;modal fade bs-example-modal-sm&quot; tabindex=&quot;-1&quot;&gt;</code> <strong>加上fade类有淡入淡出的特效</strong></p>
</li>
<li><p><code>data-whatever=&quot;&quot;</code> 当一堆按钮要使用同一个模态框时，用这个来传入分别的数据。然而对angular来说完全没必要，毕竟数据绑定了。</p>
</li>
<li><p><code>data-toggle=&quot;dropdown&quot;</code> angular感觉用处不大没细看</p>
</li>
<li><p><code>data-spy=&quot;scroll&quot; data-target=&quot;#navbar-example&quot;</code> 滚动时顺便修改选项</p>
</li>
<li><p><code>data-toggle=&quot;tab&quot;</code> </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;a href="#ejb" tabindex="-1" data-toggle="tab"&gt;//tab项</div><div class="line">&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;div class="tab-pane fade" id="ios"&gt;...&lt;/div&gt;//tab内容</div></pre></td></tr></table></figure>
</li>
<li><p><code>data-toggle=&quot;tooltip&quot; data-placement=&quot;right&quot; title=&quot;Tooltip on right&quot;</code> //表示右边显示tooltip，可以左上下</p>
</li>
<li><p><code>data-container=&quot;body&quot; data-toggle=&quot;popover&quot; data-placement=&quot;left&quot; data-content=&quot;Vivamus sagittis lacus vel augue laoreet rutrum faucibus.&quot;</code> 点击弹出带指定箭头的属性窗口，点击再消失； 多个title=”…”的话弹出窗口会多个标题显示。</p>
</li>
<li><p><code>data-loading-text=&quot;Loading...&quot;</code> 这个我没写全，它展示的效果是点击后显示加载，鼠标禁止，加载完再恢复。</p>
</li>
<li><p><code>data-dismiss=&quot;alert&quot;</code> 这个用于页内嵌入提示框，由于提供各种可使用的格式 <code>alert-warning</code> <code>alert-success</code>。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myAlert"</span> <span class="attr">class</span>=<span class="string">"alert alert-success"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"alert"</span>&gt;</span>&amp;times;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">strong</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>结果是成功的。</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>点关闭也确实能(不能也可以加个ng-hide)，但是动画效果不知道咋实现</p>
<ul>
<li><p><code>data-loading-text</code>好是好就是没法配合angular使用，只能自己写.</p>
</li>
<li><p><code>data-toggle=&quot;collapse&quot;</code> 折叠显示内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">href</span>=<span class="string">"#collapseExample"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-controls</span>=<span class="string">"collapseExample"</span>&gt;</span></div><div class="line">  Link with href</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#collapseExample"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-controls</span>=<span class="string">"collapseExample"</span>&gt;</span></div><div class="line">  Button with data-target</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse"</span> <span class="attr">id</span>=<span class="string">"collapseExample"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"well"</span>&gt;</span></div><div class="line">    ...</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>由于这俩个button链接的是一个折叠内容，点击展开，再点折叠。 里么href和data-target达到了相同效果，我想angular估计只能用data-target</p>
<p>一般 aria-*是识别属性，但是这里<code>aria-expanded=&quot;true&quot;</code>会默认展开内容</p>
<ul>
<li><code>data-ride=&quot;carousel&quot;</code>这是个轮播控件来达到相册的效果，<code>.carousel-caption</code>添加标题显示</li>
</ul>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>12网格式<br><code>.col-xs-*</code> Extra small devices (<768px) `.col-sm-*`="" small="" devices="" tabllets(="">=768px)<br><code>.col-md-*</code> Medium devices(&gt;=922px)<br><code>.col-lg-*</code> Large devices(&gt;=1200px)</768px)></p>
<p><code>*-offset-*</code>表示偏移</p>
<p>强制换行用<code>&lt;div class=&quot;row&quot;&gt;</code> 这样即使内部元素也会强制换行</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/218.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;bootstrap语法太丰富了，完全可以把很多js代码去掉。所以记录下来&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v3.bootcss.com/components/&quot; target
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="前端" scheme="https://xuecat.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="bootstrap" scheme="https://xuecat.github.io/tags/bootstrap/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XueCat</title>
  <subtitle>用代码创造世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuecat.github.io/"/>
  <updated>2020-03-29T10:59:22.643Z</updated>
  <id>https://xuecat.github.io/</id>
  
  <author>
    <name>XueCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EF Core Linq(252)</title>
    <link href="https://xuecat.github.io/2020/03/29/252/"/>
    <id>https://xuecat.github.io/2020/03/29/252/</id>
    <published>2020-03-29T02:42:32.000Z</published>
    <updated>2020-03-29T10:59:22.643Z</updated>
    
    <content type="html"><![CDATA[<p>EF默认情况下对数据的访问都是启用模型跟踪</p>
<p>使用AsNoTracking方法查询返回无变动跟踪的Province的DbSet，由于是无变动跟踪，所以对返回的Province集中数据的任何修改，在SaveChanges()时，都不会提交到数据库中</p>
<ul>
<li><p>无跟踪查询而已，也就是说查询出来的对象不能直接做修改。所以，我们在做数据集合查询显示，而又不需要对集合修改并更新到数据库的时候，一定不要忘记加上AsNoTracking。</p>
</li>
<li><p>如果查询过程做了select映射就不需要加AsNoTracking。如：db.Students.Where(t=&gt;t.Name.Contains(“张三”)).select(t=&gt;new (t.Name,t.Age)).ToList();</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导出部分属性列，提高效率</span></div><div class="line">.AsNoTracking()</div><div class="line">   .Select(item =&gt;</div><div class="line">   <span class="keyword">new</span> ProductViewModel</div><div class="line">   &#123;</div><div class="line">       Product = item,</div><div class="line"></div><div class="line">       NoOfProducts = item.Comments.Count</div><div class="line"></div><div class="line">  &#125;).ToListAsync());</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//同理</span></div><div class="line">  <span class="keyword">var</span> <span class="keyword">list</span> = context.Bloggers</div><div class="line">    .<span class="keyword">Include</span>(x =&gt; x.Posts)</div><div class="line">    .ToList();</div></pre></td></tr></table></figure>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//更新单列</span></div><div class="line">using (<span class="type">TestDBContext</span> testDBContext = <span class="function"><span class="keyword">new</span> <span class="title">TestDBContext</span>())</span></div><div class="line">&#123;</div><div class="line">    <span class="title">Person</span> <span class="title">person</span> = <span class="title">new</span> <span class="title">Person</span>() &#123; <span class="title">Code</span> = "<span class="title">A</span>" ,<span class="title">Name</span>="<span class="title">Tom</span>"&#125;;<span class="comment">//列Code是Key，声明Key属性列Code的值，及要修改的列Name的值</span></div><div class="line"></div><div class="line">    <span class="title">testDBContext</span>.<span class="title">Attach</span>(person);<span class="comment">//告诉EF Core开始跟踪person实体的更改，因为调用DbContext.Attach方法后，EF Core会将person实体的State值（可以通过testDBContext.Entry(person).State查看到）更改回EntityState.Unchanged，所以这里testDBContext.Attach(person)一定要放在下面一行testDBContext.Entry(person).</span></div><div class="line">    </div><div class="line">    <span class="title">Property</span>(p =&gt; p.<span class="type">Name</span>).<span class="title">IsModified</span> = <span class="title">true</span>的前面，否者后面的<span class="title">testDBContext</span>.<span class="title">SaveChanges</span>方法调用后，数据库不会被更新</div><div class="line">    <span class="title">testDBContext</span>.<span class="title">Entry</span>(person).<span class="title">Property</span>(p =&gt; p.<span class="type">Name</span>).<span class="title">IsModified</span> = <span class="title">true</span>;<span class="comment">//告诉EF Core实体person的Name属性已经更改。将testDBContext.Entry(person).Property(p =&gt; p.Name).IsModified设置为true后，也会将person实体的State值（可以通过testDBContext.Entry(person).State查看到）更改为EntityState.Modified，这样就保证了下面SaveChanges的时候会将person实体的Name属性值Update到数据库中。</span></div><div class="line">    <span class="title">testDBContext</span>.<span class="title">SaveChanges</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="title">context</span>.<span class="title">Attach</span>(person);</div><div class="line"><span class="title">context</span>.<span class="title">Entry</span>(person).<span class="title">Property</span>("<span class="type">Name</span>").<span class="title">IsModified</span> = <span class="title">true</span>;</div><div class="line"><span class="title">context</span>.<span class="title">SaveChanges</span>();</div><div class="line"></div><div class="line"><span class="comment">//modelBuilder.Entity&lt;Person&gt;(entity =&gt;</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//    entity.Property(e =&gt; e.Id).ValueGeneratedOnAdd();//这句会用到的</span></div><div class="line"><span class="comment">//    entity.HasKey(e =&gt; e.Code);//声明列Code是实体的Key属性</span></div><div class="line"><span class="comment">//&#125;);</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EF默认情况下对数据的访问都是启用模型跟踪&lt;/p&gt;
&lt;p&gt;使用AsNoTracking方法查询返回无变动跟踪的Province的DbSet，由于是无变动跟踪，所以对返回的Province集中数据的任何修改，在SaveChanges()时，都不会提交到数据库中&lt;/p&gt;
&lt;ul
    
    </summary>
    
      <category term="服务器" scheme="https://xuecat.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Mysql" scheme="https://xuecat.github.io/tags/Mysql/"/>
    
      <category term="Asp.Net" scheme="https://xuecat.github.io/tags/Asp-Net/"/>
    
  </entry>
  
  <entry>
    <title>Orleans新记录(251)</title>
    <link href="https://xuecat.github.io/2020/02/02/251/"/>
    <id>https://xuecat.github.io/2020/02/02/251/</id>
    <published>2020-02-02T04:31:32.000Z</published>
    <updated>2020-03-29T02:42:17.907Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Grain Identity</em></strong></p>
<ul>
<li>获取key有多样的（继承多样：<code>IGrainWithIntegerKey</code>）</li>
</ul>
<p><strong><em>Timers and Reminders</em></strong></p>
<ul>
<li><p><strong><em>Observers</em></strong></p>
</li>
<li>服务端<code>ObserverSubscriptionManager&lt;&gt;</code> <code>IGrainObserver</code>保持订阅列表，调相应接口来进行通知对应订阅</li>
<li>客户端<code>CreateObjectReference</code> <code>Subscribe</code>向服务器订阅</li>
</ul>
<p><strong><em>Reentrancy</em></strong></p>
<ul>
<li>grain类用<code>[Reentrant]</code>能完全异步，外部调它的方法顺序全是乱的。</li>
<li><code>[AlwaysInterleave]</code>单个方法异步</li>
<li>如果没有异步要注意方法里面出现<code>GetGrain</code>导致的<code>grain</code>之间互相调用会死锁</li>
<li>服务端可以写个属性来进行动态异步交错(感觉没啥用呢)</li>
</ul>
<p><strong><em>RequestContext</em></strong></p>
<ul>
<li>客户端<code>RequestContext.Set</code>，服务端<code>RequestContext.Get</code>它将与Orleans请求一起流向接收谷物;<br>应用程序元数据不会随响应一起流回<br>应用场景：请求从客户端到服务器跟踪流程用</li>
</ul>
<p><strong><em>JournaledGrain</em></strong></p>
<p><strong><em>Reentrancy</em></strong></p>
<p><strong><em>Reentrancy</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;Grain Identity&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取key有多样的（继承多样：&lt;code&gt;IGrainWithIntegerKey&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Timers 
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="分布式" scheme="https://xuecat.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Orleans" scheme="https://xuecat.github.io/tags/Orleans/"/>
    
  </entry>
  
  <entry>
    <title>for(;;)和while(true)(250)</title>
    <link href="https://xuecat.github.io/2019/12/11/250/"/>
    <id>https://xuecat.github.io/2019/12/11/250/</id>
    <published>2019-12-11T15:39:46.000Z</published>
    <updated>2019-12-11T15:46:02.681Z</updated>
    
    <content type="html"><![CDATA[<p>比较结果<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">while(1)</div><div class="line"></div><div class="line">mov eax,1</div><div class="line"><span class="keyword">test </span>eax,eax</div><div class="line">je foo<span class="string">+23</span>h</div><div class="line">jmp foo<span class="string">+18</span>h</div><div class="line"></div><div class="line"></div><div class="line">for(;;)</div><div class="line"></div><div class="line">jmp foo<span class="string">+23</span>h</div></pre></td></tr></table></figure></p>
<p>总结:for (;;):1.指令少2.不占用寄存器3.没有判断跳转,并不是不能跳出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较结果&lt;br&gt;&lt;figure class=&quot;highlight subunit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>服务器记录(249)</title>
    <link href="https://xuecat.github.io/2019/10/28/249/"/>
    <id>https://xuecat.github.io/2019/10/28/249/</id>
    <published>2019-10-28T15:22:06.000Z</published>
    <updated>2019-10-28T15:33:30.154Z</updated>
    
    <content type="html"><![CDATA[<p>  最近优化了些服务器做下记录</p>
<ol>
<li>httpclient的使用<blockquote>
<p>httpclient不能立即关闭，会占用资源，并发量一大就耗尽。所以.net core 会使用如下:</p>
</blockquote>
</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GitHubClient</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> HttpClient Client &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GitHubClient</span>(<span class="params">HttpClient httpClient</span>)</span></div><div class="line">    &#123;</div><div class="line">        httpClient.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://api.github.com/"</span>);</div><div class="line">        httpClient.DefaultRequestHeaders.Add(<span class="string">"Accept"</span>, <span class="string">"application/vnd.github.v3+json"</span>);</div><div class="line">        httpClient.DefaultRequestHeaders.Add(<span class="string">"User-Agent"</span>, <span class="string">"HttpClientFactory-Sample"</span>);</div><div class="line">        Client = httpClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">GetData</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">await</span> _client.GetStringAsync(<span class="string">"/"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">services.AddHttpClient&lt;GitHubClient&gt;();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">BaseController</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GitHubClient _gitHubClient;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValuesController</span>(<span class="params">GitHubClient gitHubClient</span>)</span></div><div class="line">    &#123;</div><div class="line">        _gitHubClient = gitHubClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [HttpGet]</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">Get</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">string</span> result = <span class="keyword">await</span> _gitHubClient.GetData();</div><div class="line">        <span class="keyword">return</span> Ok(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我的做法是使用全局static来控制。</p>
<ol>
<li><p>在异步方法中，不要使用 Thread.Sleep；在同步方法中，不要使用Task.Delay ，否则可能出现线程死锁，结果难出来。</p>
</li>
<li><p>吞吐量（TPS）、QPS（每秒查询率）、并发数、响应时间（RT）<br>当时为了增加qps，把所有webapi接口都改成异步请求</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近优化了些服务器做下记录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;httpclient的使用&lt;blockquote&gt;
&lt;p&gt;httpclient不能立即关闭，会占用资源，并发量一大就耗尽。所以.net core 会使用如下:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol
    
    </summary>
    
      <category term="服务器" scheme="https://xuecat.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="分布式" scheme="https://xuecat.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单元测试白盒(248)</title>
    <link href="https://xuecat.github.io/2019/05/19/248/"/>
    <id>https://xuecat.github.io/2019/05/19/248/</id>
    <published>2019-05-19T07:31:39.000Z</published>
    <updated>2019-09-04T15:49:31.737Z</updated>
    
    <content type="html"><![CDATA[<p><em>昨天下雨了!好像！</em><br><blockquote><p>外面风雨琳琅，漫山遍野都是今天。</p>
</blockquote></p>
<h2 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h2><p>  vs支持的白盒测试项目的编写。一般用来测试接口的</p>
<ul>
<li>测试项目引用必须引用到实体项目</li>
<li>测试项目链接必须连接到实体项目中间文件: ../test/Debug/test.obj.</li>
<li>包含头文件 <code>#include &quot;../test/test.h&quot;</code></li>
</ul>
<hr>
<p>  c#的要简单点，直接引用项目，然后调用就可以了。<br>  唯一的问题在于dot net core的测试项目的创建。mstest,nunit,xunit这三个项目，好像社区用xunit来创建多些，还能跨平台。</p>
<hr>
<p>  <code>Assert.Equal</code>几乎都是用这个。</p>
<p><strong>然后看同步的测试项目：</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;昨天下雨了!好像！&lt;/em&gt;&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;外面风雨琳琅，漫山遍野都是今天。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试项目&quot;&gt;&lt;a href=&quot;#测试项目&quot; class=&quot;headerlink&quot; title=&quot;测试项目&quot;
    
    </summary>
    
      <category term="测试" scheme="https://xuecat.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
      <category term="学习看书笔记" scheme="https://xuecat.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%9C%8B%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>资源问题(247)</title>
    <link href="https://xuecat.github.io/2018/11/26/247/"/>
    <id>https://xuecat.github.io/2018/11/26/247/</id>
    <published>2018-11-26T13:58:52.000Z</published>
    <updated>2018-11-26T14:13:05.162Z</updated>
    
    <content type="html"><![CDATA[<p> 今天说给收录写个新功能来着，搞半天老是资源错误，”试图执行的操作不受支持”。气死人了。<br> 最后想起在DoDataExchange下个断点，一个一个的找资源控件问题，</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 今天说给收录写个新功能来着，搞半天老是资源错误，”试图执行的操作不受支持”。气死人了。&lt;br&gt; 最后想起在DoDataExchange下个断点，一个一个的找资源控件问题，&lt;/p&gt;

    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="mfc" scheme="https://xuecat.github.io/tags/mfc/"/>
    
  </entry>
  
  <entry>
    <title>高性能mysql(246)</title>
    <link href="https://xuecat.github.io/2018/10/22/246/"/>
    <id>https://xuecat.github.io/2018/10/22/246/</id>
    <published>2018-10-22T15:52:18.000Z</published>
    <updated>2019-09-04T16:13:52.090Z</updated>
    
    <content type="html"><![CDATA[<p><strong>schema</strong></p>
<ul>
<li><p>尽量避免<code>NULL</code>, 可为<code>NULL</code>的列使得索引 索引统计和值比较都更为复杂，可为<code>NULL</code>的列会使用更多空间</p>
</li>
<li><p>整数类型, INT(11),并不会限制值的合法范围,只是规定MYSQL显示字符的个数;<code>DECIMAL</code>是浮点型</p>
</li>
<li><p>字符类型,<code>VARCHAR</code>存储变长字符串,比定长<code>CHAR</code>(md5等这种来存储)更省空间.会额外多1到2个字节来存储长度</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;schema&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;尽量避免&lt;code&gt;NULL&lt;/code&gt;, 可为&lt;code&gt;NULL&lt;/code&gt;的列使得索引 索引统计和值比较都更为复杂，可为&lt;code&gt;NULL&lt;/code&gt;的列会使用更多空间&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://xuecat.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql(245)</title>
    <link href="https://xuecat.github.io/2018/09/23/245/"/>
    <id>https://xuecat.github.io/2018/09/23/245/</id>
    <published>2018-09-22T17:39:53.000Z</published>
    <updated>2018-09-22T17:46:44.403Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>约束</p>
<ul>
<li>非空约束(not null)</li>
<li>唯一性约束(unique)</li>
<li>主键约束(primary key) PK</li>
<li>外键约束(foreign key) FK</li>
<li>检查约束(目前MySQL不支持、Oracle支持)</li>
</ul>
</li>
<li><p>非空约束</p>
<ul>
<li><code>name varchar(32) not null</code></li>
</ul>
</li>
<li><p>唯一约束 (表之间插入相同值会报错)</p>
<ul>
<li><code>email varchar(128) unique</code></li>
<li><code>email varchar(128), unique(name,email)</code></li>
<li><code>constraint t_user_email_unique unique(email)</code>给约束表起名,方便以后删除</li>
</ul>
</li>
<li><p>主键约束</p>
<ul>
<li><code>id int(10) primary key</code> 单一列级</li>
<li><code>constraint t_user_id_pk primary key(id)</code> 单一表级</li>
<li><code>primary key(id,name)</code> 符合表级</li>
<li>主键自增 <figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">reate table <span class="title">t_user</span>(<span class="params"></span></span></div><div class="line"> id <span class="keyword">int</span>(<span class="number">10</span>) primary key auto_increment,</div><div class="line"> name <span class="title">varchar</span>(<span class="params"><span class="number">32</span></span>) not <span class="literal">null</span></div><div class="line"> );</div><div class="line"></div><div class="line"><span class="function">insert <span class="keyword">into</span> <span class="title">t_user</span>(<span class="params">name</span>) <span class="title">values</span>(<span class="params"><span class="string">'jay'</span></span>)</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>外键约束</p>
</li>
</ul>
<ul>
<li><code>FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)</code></li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><code>字段建立索引可以大大提升查询速度</code></p>
<ul>
<li><p>普通索引</p>
<ul>
<li><code>CREATE INDEX indexName ON mytable(username(length))</code></li>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) )</code></li>
</ul>
</li>
<li><p>唯一索引<br>  它必须唯一,但允许有空值</p>
<ul>
<li><code>CREATE UNIQUE INDEX indexName ON mytable(username(length))</code></li>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) )</code></li>
</ul>
</li>
<li><p>主键索引<br>  唯一且不允许空</p>
<ul>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );</code></li>
</ul>
</li>
<li><p>组合索引</p>
<ul>
<li><code>ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</code></li>
</ul>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>varchar最好在1024以内,虽然它能支持到6553;其它用blob和text来代替</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;约束&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非空约束(not null)&lt;/li&gt;
&lt;li&gt;唯一性约束(unique)&lt;/li&gt;
&lt;li&gt;主键约束(primary key) PK&lt;/li&gt;
&lt;li&gt;外键约束(foreign key) FK&lt;/li&gt;
&lt;li&gt;检查约束(
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://xuecat.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Xsum问题(243)</title>
    <link href="https://xuecat.github.io/2018/09/04/243/"/>
    <id>https://xuecat.github.io/2018/09/04/243/</id>
    <published>2018-09-04T14:40:16.000Z</published>
    <updated>2018-09-25T15:38:00.270Z</updated>
    
    <content type="html"><![CDATA[<h3 id="xsum问题"><a href="#xsum问题" class="headerlink" title="xsum问题"></a>xsum问题</h3><ul>
<li><p>2sum</p>
<ul>
<li><p>map结构时间复杂度O(n)<br>map把那些离target有差距的都存起来，等target-nums[i]有对应值时，就表示达到了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">int</span> len = nums.size();</div><div class="line">    <span class="keyword">if</span> ( len &lt; <span class="number">2</span>) </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++)&#123;</div><div class="line">        <span class="keyword">if</span> (mp[target - nums[i]] != <span class="number">0</span>)&#123;</div><div class="line">            res.push_back(mp[target - nums[i]] - <span class="number">1</span>);<span class="comment">//减去加的那个1</span></div><div class="line">            res.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            mp[nums[i]] = i + <span class="number">1</span>;<span class="comment">//故意加了1是为了防止为0,这样好判断这个键-值是否存在</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//sort(res.begin(), res.end());</span></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>先对数据进行排序，如果用STL的sort快排，时间复杂度为O(nlogn)，然后设置两个指针，一个初始化为数组的头，一个初始化在数组的尾，然后两边向中间扫描，如果当前两个指针指向的数的和正好是target，那么就保存当前数对 (防止重复就跳过相同值)<br>这个方法找多个就很麻烦了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">int</span> len = nums.size();</div><div class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numsTmp = nums;</div><div class="line">    sort(nums.begin(), nums.end()); <span class="comment">//使得有序</span></div><div class="line"></div><div class="line">    <span class="comment">//收尾指针法</span></div><div class="line">    <span class="keyword">int</span> sta = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> end = len - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (sta &lt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (nums[sta] + nums[end] == target)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">bool</span> f1 = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">bool</span> f2 = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//排序队列找到了，还要去原来队列找到对应的值序列号</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (f1 &amp;&amp; f2)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (!f1 &amp;&amp; numsTmp[i] == nums[sta]) <span class="comment">// nums[sta] 可能等于 nums[end]</span></div><div class="line">                &#123;</div><div class="line">                    res.push_back(i);</div><div class="line">                    f1 = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!f2 &amp;&amp; numsTmp[i] == nums[end]) <span class="comment">// 这里是else if 不是if</span></div><div class="line">                &#123;</div><div class="line">                    res.push_back(i);</div><div class="line">                    f2 = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[sta] + nums[end] &lt; target)<span class="comment">//单方面递增或递减</span></div><div class="line">        &#123;</div><div class="line">            sta++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3sum</p>
<ul>
<li>依次对数组中得每一个元素num[i]找和为target-num[i]的连个数，这样问题又回到了2Sum上</li>
</ul>
</li>
<li><p>4sum</p>
<ul>
<li><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;int&gt; &gt; fourSum(<span class="built_in">vector</span>&lt;int&gt; &amp;<span class="built_in">num</span>, int target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;int&gt; &gt; ret;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">num</span>.size() == <span class="number">0</span>) <span class="built_in">return</span> ret;</div><div class="line"></div><div class="line">    <span class="built_in">sort</span>(<span class="built_in">num</span>.begin(), <span class="built_in">num</span>.end());</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (size_t a = <span class="number">0</span>; a &lt; <span class="built_in">num</span>.size(); ++a)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (a != <span class="number">0</span> &amp;&amp; <span class="built_in">num</span>[a] == <span class="built_in">num</span>[a-<span class="number">1</span>])</div><div class="line">            continue;</div><div class="line">    </div><div class="line">        <span class="keyword">for</span> (size_t b = a + <span class="number">1</span>; b &lt; <span class="built_in">num</span>.size(); ++b)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (b != a + <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[b] == <span class="built_in">num</span>[b-<span class="number">1</span>])</div><div class="line">                continue;</div><div class="line">        </div><div class="line">            size_t c = b + <span class="number">1</span>;</div><div class="line">            size_t d = <span class="built_in">num</span>.size() - <span class="number">1</span>;</div><div class="line">        </div><div class="line">            <span class="keyword">while</span> (c &lt; d)</div><div class="line">            &#123;</div><div class="line">                const int <span class="built_in">sum</span> = <span class="built_in">num</span>[a] + <span class="built_in">num</span>[b] + <span class="built_in">num</span>[c] + <span class="built_in">num</span>[d];</div><div class="line">            </div><div class="line">                <span class="keyword">if</span> (<span class="built_in">sum</span> &gt; target)</div><div class="line">                    --d;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sum</span> &lt; target)</div><div class="line">                    ++c;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c != b + <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[c] == <span class="built_in">num</span>[c-<span class="number">1</span>])</div><div class="line">                    ++c;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d != <span class="built_in">num</span>.size() - <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[d] == <span class="built_in">num</span>[d+<span class="number">1</span>])</div><div class="line">                    --d;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">vector</span>&lt;int&gt; result;</div><div class="line">                </div><div class="line">                    result.push_back(<span class="built_in">num</span>[a]);</div><div class="line">                    result.push_back(<span class="built_in">num</span>[b]);</div><div class="line">                    result.push_back(<span class="built_in">num</span>[c]);</div><div class="line">                    result.push_back(<span class="built_in">num</span>[d]);</div><div class="line">                </div><div class="line">                    ret.push_back(result);</div><div class="line">                </div><div class="line">                    ++c;</div><div class="line">                    --d;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;xsum问题&quot;&gt;&lt;a href=&quot;#xsum问题&quot; class=&quot;headerlink&quot; title=&quot;xsum问题&quot;&gt;&lt;/a&gt;xsum问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2sum&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;map结构时间复杂度O(n)&lt;br&gt;map把那些
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
      <category term="算法" scheme="https://xuecat.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>permutation(242)</title>
    <link href="https://xuecat.github.io/2018/08/19/242/"/>
    <id>https://xuecat.github.io/2018/08/19/242/</id>
    <published>2018-08-19T09:32:02.000Z</published>
    <updated>2018-08-19T10:22:13.521Z</updated>
    
    <content type="html"><![CDATA[<p>排列算法<code>stl</code>里面的<code>next_permutation</code>和<code>prev_permutation</code></p>
<h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a><code>next_permutation</code></h4><ol>
<li>从尾部开始往前寻找两个相邻的元素,第1个元素i，第2个元素j（从前往后数的），且i&lt;j</li>
<li>在[j,end)中寻找一个最小的k使其满足A[i]&lt;A[k],将i与k交换</li>
<li>[j,last)范围的元素置逆（颠倒排列）</li>
</ol>
<blockquote>
<p>1,3,2-&gt; 2,1,3过程<br>i是1，j是3. k是3；互换后是3,1,2; 由于j是3，逆序就是2,1,3了</p>
</blockquote>
<h4 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a><code>prev_permutation</code></h4><ol>
<li>从尾部开始往前寻找两个相邻的元素,第1个元素i，第2个元素j（从前往后数的），且i&gt;j</li>
<li>从最尾端开始往前寻找第一个小于i的元素，令它为k, 讲i和k对调</li>
<li>j之后颠倒</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排列算法&lt;code&gt;stl&lt;/code&gt;里面的&lt;code&gt;next_permutation&lt;/code&gt;和&lt;code&gt;prev_permutation&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;next-permutation&quot;&gt;&lt;a href=&quot;#next-permutati
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
      <category term="算法" scheme="https://xuecat.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c++的currying(241)</title>
    <link href="https://xuecat.github.io/2018/08/09/241/"/>
    <id>https://xuecat.github.io/2018/08/09/241/</id>
    <published>2018-08-08T16:06:25.000Z</published>
    <updated>2018-08-08T16:07:17.114Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">partial</span><span class="params">(F f, Args... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span>... rest) -&gt; <span class="keyword">auto</span> &#123;<span class="comment">//草这就是c++的lamda，和js c#的完全不同啊，我这个笨蛋第一时间居然没反应过来</span></div><div class="line">        <span class="keyword">return</span> f(args..., rest...);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> &amp; b, <span class="keyword">int</span> c, <span class="keyword">int</span> &amp; d)</span> </span>&#123;</div><div class="line">    b = b + <span class="number">1</span>;</div><div class="line">    d = d + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">11</span>, b = <span class="number">111</span>, c = <span class="number">1111</span>, d = <span class="number">11111</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="string">" d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    partial(demo, a, <span class="built_in">std</span>::ref(b))(c, <span class="built_in">std</span>::ref(d));</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="string">" d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>stl排序(240)</title>
    <link href="https://xuecat.github.io/2018/07/28/240/"/>
    <id>https://xuecat.github.io/2018/07/28/240/</id>
    <published>2018-07-28T08:09:45.000Z</published>
    <updated>2018-07-28T09:16:01.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">以前有笔记，但忘了放哪了，再做一次吧</blockquote>

<p><img src="/picture/240.jpg" alt=""></p>
<ul>
<li>stable_sort</li>
<li>partial_sort</li>
<li>nth_element</li>
<li>partition和stable_partition</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> w&amp; l, <span class="keyword">const</span> w&amp; r)</span> </span>&#123;...&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifunc</span><span class="params">(<span class="keyword">const</span> w&amp; c)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<h4 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h4><pre><code>只排一部分：`partial_sort(w.begin(),w.beging()+20,w.end(),func)`只对前20个元素排
</code></pre><h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h4><pre><code>只分界:`nth_element(w.begin(),w.beging()+20,w.end(),func)`
将最后的20个元素放前面，但它不会像前面那个函数，这个函数不会排序，只是单纯放前面
</code></pre><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><pre><code>前面俩个只会比较元素，当判断元素属性时呢
`partition(w.begin(), w.end(), ifunc)`功能类似`partial_sort`但比较函数不同
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;以前有笔记，但忘了放哪了，再做一次吧&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/picture/240.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stable_sort&lt;/li&gt;

    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>mysql检索(239)</title>
    <link href="https://xuecat.github.io/2018/07/13/239/"/>
    <id>https://xuecat.github.io/2018/07/13/239/</id>
    <published>2018-07-12T16:49:11.000Z</published>
    <updated>2018-07-12T16:53:29.982Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Å, å，这是丹麦的</div><div class="line">Ä ä，这是德语的</div><div class="line">A <span class="selector-tag">a</span> 这是英文得</div></pre></td></tr></table></figure>
<p>mysql里校对包含字符时有这些<code>like</code> <code>instr</code> <code>locate</code>,<br>但它们时建立在一个校对规则之上的,<br><code>_unicode_ci</code>不区分大小写<br><code>_general_ci</code>不区分大小写<br><code>*_cs</code>区分大小写<br><code>*_bin</code>用二进制存储</p>
<p>utf8_general_ci 校对速度快，但准确度稍差<br>utf8_unicode_ci 准确度高，但校对速度稍慢(所以最近那个sql问题我该改成这个)</p>
<p>utf8mb4字符集可以保存表情符号.</p>
<p>最后直接限定字符检索才成功，不明白为何改<code>_bin</code>也不成功。唉！<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbp_log_object <span class="keyword">as</span> a <span class="keyword">WHERE</span> <span class="keyword">locate</span>(<span class="string">'Ä'</span> <span class="keyword">collate</span> utf8_bin, a.objectname)&gt;<span class="number">0</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>orleans(238)</title>
    <link href="https://xuecat.github.io/2018/07/06/238/"/>
    <id>https://xuecat.github.io/2018/07/06/238/</id>
    <published>2018-07-06T13:00:29.000Z</published>
    <updated>2018-07-10T16:00:54.412Z</updated>
    
    <content type="html"><![CDATA[<p>这个亚马逊云素材同步代码是我至今最大坡度的代码<br>第一次有种想早点下班好回去恶补知识的感觉,可惜又不得不加班完成任务。</p>
<ol>
<li>silo 代表一个服务，可以是主节点也可以是副节点</li>
<li><p>grain 可以看作是一个单例进程，队列只有一个，会排队修改数据。相同类型的只要key不同，它们就互相独立</p>
</li>
<li><p>客户端一开始就会连接一个服务即silo.(GrainClient.Initialize)</p>
</li>
<li><p>StreamProvider订阅，无论是隐式还是显式，都要用this.stream.OnNextAsync(data)去分发<br>显式还是隐式都是一个grain，初始化注册订阅后才能使用</p>
</li>
</ol>
<ol>
<li><p>Orleans.Immutable 这个是由于和grain的方法调用传参是一次深拷贝<br>grain之间通信，silo之间通信也是深拷贝。<br>为了避免，所以用这个来控制，避免深拷贝。</p>
</li>
<li><p>Orleans永远不会在执行Task的中途创造另一个Task,所以要求程序代码在执行Task的中途,不要开辟多线程.不然会报错或者会破坏单线程机制.如果真的有需要创造额外的task.</p>
</li>
<li><p><code>StatelessWorker</code>的<code>grain</code>，状态无关类型；可以在集群的多个silo里,每一个silo都创造一个相同标识的Grain。 针对此类grain的请求,都只在第一个接受到请求的silo里执行。 Orleans会在所有此类grain忙的时候,自动增加一个</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个亚马逊云素材同步代码是我至今最大坡度的代码&lt;br&gt;第一次有种想早点下班好回去恶补知识的感觉,可惜又不得不加班完成任务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;silo 代表一个服务，可以是主节点也可以是副节点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;grain 可以看作是一个单例进程，队列只有一个
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="分布式" scheme="https://xuecat.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>せいかつの日記(237)</title>
    <link href="https://xuecat.github.io/2018/07/04/237/"/>
    <id>https://xuecat.github.io/2018/07/04/237/</id>
    <published>2018-07-03T16:06:56.000Z</published>
    <updated>2018-08-06T15:11:13.266Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/237.png" alt=""></p>
<hr>
<pre><code>見ないでくたさい、ただ馬鹿な話しです
</code></pre><hr>
<h2 id="2018-7-3"><a href="#2018-7-3" class="headerlink" title="2018/7/3"></a>2018/7/3</h2><p>やっと、reactのプロジェクトおわりました、少しごめなことあるですけれど。</p>
<p>も、次の仕事用意してる</p>
<p>Amazon cloud synchronization</p>
<p>ああ！！メチや　メチや、難しいです；頭もだめちや</p>
<h2 id="2018-7-6"><a href="#2018-7-6" class="headerlink" title="2018/7/6"></a>2018/7/6</h2><p>ああ！あ！　ついに、負け犬をなちゃた<br>残業中に食物をあげで、そんな事はまったく思わなかったです。<br>相手は強すぎる、俺は彼の前に全然駄目です。<br>ちょっとだけない。。。。。、悲しいです。<br>どうするつもり、僕もわからない。<br>せめて答えをもらう</p>
<h2 id="2018-7-9"><a href="#2018-7-9" class="headerlink" title="2018/7/9"></a>2018/7/9</h2><p>山なほと仕事<br>恋は雨上がりのように</p>
<h2 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018/7/10"></a>2018/7/10</h2><p>父さんと母さんがきちゃった、猫も</p>
<h2 id="2018-7-24"><a href="#2018-7-24" class="headerlink" title="2018/7/24"></a>2018/7/24</h2><p>誰でもいい、彼女の事欲しい、ときとぎそう思うた<br>きっと、俺は寂しくすぎた<br>大切にされたかったら　安売りするな。</p>
<h2 id="2018-8-6"><a href="#2018-8-6" class="headerlink" title="2018/8/6"></a>2018/8/6</h2><p>ごめんれ、きっと僕は狡いです、罪がある。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/237.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;見ないでくたさい、ただ馬鹿な話しです
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;2018-7-3&quot;&gt;&lt;a href=&quot;#2018-7-3&quot; class=
    
    </summary>
    
      <category term="生活" scheme="https://xuecat.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>decimal类型(236)</title>
    <link href="https://xuecat.github.io/2018/06/30/236/"/>
    <id>https://xuecat.github.io/2018/06/30/236/</id>
    <published>2018-06-30T07:59:25.000Z</published>
    <updated>2018-06-30T11:51:21.734Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>js forin顺序(235)</title>
    <link href="https://xuecat.github.io/2018/06/17/235/"/>
    <id>https://xuecat.github.io/2018/06/17/235/</id>
    <published>2018-06-17T06:21:10.000Z</published>
    <updated>2018-06-17T06:46:47.868Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/235.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>平时根本没时间写着，只好全缓存，周末更新上来，唉！！
得找个时间再去看下markdown语法了，排版真特么丑。
</code></pre><p>装逼封装了excel读写的js，forin排序居然用到了，笔记下：</p>
<pre><code>js for in顺序，不会按照定义顺序输出；好像浏览器没按以前标准了;
它处理方式是先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>stl的swap和(234)</title>
    <link href="https://xuecat.github.io/2018/06/17/234/"/>
    <id>https://xuecat.github.io/2018/06/17/234/</id>
    <published>2018-06-17T06:02:20.000Z</published>
    <updated>2018-06-17T06:46:39.548Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/234.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>去p站下图片越来越少了
</code></pre><h3 id="string和vector"><a href="#string和vector" class="headerlink" title="string和vector"></a>string和vector</h3><p>它们都是线性结构，只不过是堆而已。<br>它们都有reserve的概念，所以导致它们的预定义内存</p>
<p>释放内存的方法就是都是用<code>swap</code>, <code>string().swap(s)</code></p>
<p><code>swap</code>交换技巧实现内存释放思想：</p>
<p><strong><em><code>vector()</code>使用<code>vector</code>的默认构造函数建立临时<code>vector</code>对象，再在该临对象上调用<code>swap</code>成员，<code>swap</code>调用之后对象<code>myvector</code>占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="STL" scheme="https://xuecat.github.io/categories/STL/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>c++CRTP和typename与class的区别233</title>
    <link href="https://xuecat.github.io/2018/05/26/233/"/>
    <id>https://xuecat.github.io/2018/05/26/233/</id>
    <published>2018-05-26T08:38:00.000Z</published>
    <updated>2018-06-17T06:25:24.194Z</updated>
    
    <content type="html"><![CDATA[<p><code>Curiously Recurring Template Prattern</code>即人们称的静态多态<br>由于c++的多态不能将基类的虚函数定义为模板函数，所以出现的它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> D&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(D t)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>).funcImpl(t);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base : <span class="keyword">public</span> BaseClass&lt;Base&gt;</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> BaseClass&lt;Derive&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	BaseClass&lt;Derive&gt; der;</div><div class="line">	der.Func(<span class="number">2</span>);<span class="comment">//base 2</span></div><div class="line"></div><div class="line">	BaseClass&lt;Base&gt; bas;</div><div class="line">	bas.Func(<span class="number">4</span>);<span class="comment">//derive 4</span></div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此，多态就能使用模板函数了</p>
<hr>
<p><strong>怕是最近js写多了，这个都忘了，羞愧啊！！</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> MyClass&#123;</div><div class="line">    <span class="keyword">typename</span> T::SubType * ptr;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，typename指出SubType是class T中定义的一个类别，因此ptr是一个指向T::SubType型别的指针。如果没有关键字typename，SubType会被当成一个static成员，于是<br>T::SubType * ptr<br>会被解释为型别T内的数值SubType与ptr的乘积。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Curiously Recurring Template Prattern&lt;/code&gt;即人们称的静态多态&lt;br&gt;由于c++的多态不能将基类的虚函数定义为模板函数，所以出现的它&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数据库遇见的一个问题(232)</title>
    <link href="https://xuecat.github.io/2018/05/06/232/"/>
    <id>https://xuecat.github.io/2018/05/06/232/</id>
    <published>2018-05-06T04:16:40.000Z</published>
    <updated>2018-05-06T04:21:10.090Z</updated>
    
    <content type="html"><![CDATA[<p>今天丹麦现场问题：<br>检索丹麦字符(长的像A,又不是A),出现英文A匹配和丹麦字符匹配。</p>
<p>最后发现是mysql的like语句，后面用locate语句精确才没把英文检索出来。<br>查了很久google和官方,并未给解释为啥like的模糊匹配是如此，大多讲locate比like高效。<br>所以写下记录，以后请问！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天丹麦现场问题：&lt;br&gt;检索丹麦字符(长的像A,又不是A),出现英文A匹配和丹麦字符匹配。&lt;/p&gt;
&lt;p&gt;最后发现是mysql的like语句，后面用locate语句精确才没把英文检索出来。&lt;br&gt;查了很久google和官方,并未给解释为啥like的模糊匹配是如此，大多讲l
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://xuecat.github.io/tags/Mysql/"/>
    
  </entry>
  
</feed>

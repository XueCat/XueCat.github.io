<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XueCat</title>
  <subtitle>用代码创造世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuecat.github.io/"/>
  <updated>2018-09-22T17:46:44.403Z</updated>
  <id>https://xuecat.github.io/</id>
  
  <author>
    <name>XueCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql(245)</title>
    <link href="https://xuecat.github.io/2018/09/23/245/"/>
    <id>https://xuecat.github.io/2018/09/23/245/</id>
    <published>2018-09-22T17:39:53.000Z</published>
    <updated>2018-09-22T17:46:44.403Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>约束</p>
<ul>
<li>非空约束(not null)</li>
<li>唯一性约束(unique)</li>
<li>主键约束(primary key) PK</li>
<li>外键约束(foreign key) FK</li>
<li>检查约束(目前MySQL不支持、Oracle支持)</li>
</ul>
</li>
<li><p>非空约束</p>
<ul>
<li><code>name varchar(32) not null</code></li>
</ul>
</li>
<li><p>唯一约束 (表之间插入相同值会报错)</p>
<ul>
<li><code>email varchar(128) unique</code></li>
<li><code>email varchar(128), unique(name,email)</code></li>
<li><code>constraint t_user_email_unique unique(email)</code>给约束表起名,方便以后删除</li>
</ul>
</li>
<li><p>主键约束</p>
<ul>
<li><code>id int(10) primary key</code> 单一列级</li>
<li><code>constraint t_user_id_pk primary key(id)</code> 单一表级</li>
<li><code>primary key(id,name)</code> 符合表级</li>
<li>主键自增 <figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">reate table <span class="title">t_user</span>(<span class="params"></span></span></div><div class="line"> id <span class="keyword">int</span>(<span class="number">10</span>) primary key auto_increment,</div><div class="line"> name <span class="title">varchar</span>(<span class="params"><span class="number">32</span></span>) not <span class="literal">null</span></div><div class="line"> );</div><div class="line"></div><div class="line"><span class="function">insert <span class="keyword">into</span> <span class="title">t_user</span>(<span class="params">name</span>) <span class="title">values</span>(<span class="params"><span class="string">'jay'</span></span>)</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>外键约束</p>
</li>
</ul>
<ul>
<li><code>FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)</code></li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><code>字段建立索引可以大大提升查询速度</code></p>
<ul>
<li><p>普通索引</p>
<ul>
<li><code>CREATE INDEX indexName ON mytable(username(length))</code></li>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) )</code></li>
</ul>
</li>
<li><p>唯一索引<br>  它必须唯一,但允许有空值</p>
<ul>
<li><code>CREATE UNIQUE INDEX indexName ON mytable(username(length))</code></li>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) )</code></li>
</ul>
</li>
<li><p>主键索引<br>  唯一且不允许空</p>
<ul>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );</code></li>
</ul>
</li>
<li><p>组合索引</p>
<ul>
<li><code>ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</code></li>
</ul>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>varchar最好在1024以内,虽然它能支持到6553;其它用blob和text来代替</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;约束&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非空约束(not null)&lt;/li&gt;
&lt;li&gt;唯一性约束(unique)&lt;/li&gt;
&lt;li&gt;主键约束(primary key) PK&lt;/li&gt;
&lt;li&gt;外键约束(foreign key) FK&lt;/li&gt;
&lt;li&gt;检查约束(
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://xuecat.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Xsum问题(243)</title>
    <link href="https://xuecat.github.io/2018/09/04/243/"/>
    <id>https://xuecat.github.io/2018/09/04/243/</id>
    <published>2018-09-04T14:40:16.000Z</published>
    <updated>2018-09-22T17:40:09.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="xsum问题"><a href="#xsum问题" class="headerlink" title="xsum问题"></a>xsum问题</h3><ul>
<li><p>2sum</p>
<ul>
<li>先对数据进行排序，如果用STL的sort快排，时间复杂度为O(nlogn)，然后设置两个指针，一个初始化为数组的头，一个初始化在数组的尾，然后两边向中间扫描，如果当前两个指针指向的数的和正好是target，那么就保存当前数对 (防止重复就跳过相同值)</li>
</ul>
</li>
<li><p>3sum</p>
<ul>
<li>依次对数组中得每一个元素num[i]找和为target-num[i]的连个数，这样问题又回到了2Sum上</li>
</ul>
</li>
<li><p>4sum</p>
<ul>
<li>d</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;xsum问题&quot;&gt;&lt;a href=&quot;#xsum问题&quot; class=&quot;headerlink&quot; title=&quot;xsum问题&quot;&gt;&lt;/a&gt;xsum问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2sum&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先对数据进行排序，如果用STL的sort快排，时间复杂
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
      <category term="算法" scheme="https://xuecat.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>permutation(242)</title>
    <link href="https://xuecat.github.io/2018/08/19/242/"/>
    <id>https://xuecat.github.io/2018/08/19/242/</id>
    <published>2018-08-19T09:32:02.000Z</published>
    <updated>2018-08-19T10:22:13.521Z</updated>
    
    <content type="html"><![CDATA[<p>排列算法<code>stl</code>里面的<code>next_permutation</code>和<code>prev_permutation</code></p>
<h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a><code>next_permutation</code></h4><ol>
<li>从尾部开始往前寻找两个相邻的元素,第1个元素i，第2个元素j（从前往后数的），且i&lt;j</li>
<li>在[j,end)中寻找一个最小的k使其满足A[i]&lt;A[k],将i与k交换</li>
<li>[j,last)范围的元素置逆（颠倒排列）</li>
</ol>
<blockquote>
<p>1,3,2-&gt; 2,1,3过程<br>i是1，j是3. k是3；互换后是3,1,2; 由于j是3，逆序就是2,1,3了</p>
</blockquote>
<h4 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a><code>prev_permutation</code></h4><ol>
<li>从尾部开始往前寻找两个相邻的元素,第1个元素i，第2个元素j（从前往后数的），且i&gt;j</li>
<li>从最尾端开始往前寻找第一个小于i的元素，令它为k, 讲i和k对调</li>
<li>j之后颠倒</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排列算法&lt;code&gt;stl&lt;/code&gt;里面的&lt;code&gt;next_permutation&lt;/code&gt;和&lt;code&gt;prev_permutation&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;next-permutation&quot;&gt;&lt;a href=&quot;#next-permutati
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
      <category term="算法" scheme="https://xuecat.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c++的currying(241)</title>
    <link href="https://xuecat.github.io/2018/08/09/241/"/>
    <id>https://xuecat.github.io/2018/08/09/241/</id>
    <published>2018-08-08T16:06:25.000Z</published>
    <updated>2018-08-08T16:07:17.114Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">partial</span><span class="params">(F f, Args... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span>... rest) -&gt; <span class="keyword">auto</span> &#123;<span class="comment">//草这就是c++的lamda，和js c#的完全不同啊，我这个笨蛋第一时间居然没反应过来</span></div><div class="line">        <span class="keyword">return</span> f(args..., rest...);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> &amp; b, <span class="keyword">int</span> c, <span class="keyword">int</span> &amp; d)</span> </span>&#123;</div><div class="line">    b = b + <span class="number">1</span>;</div><div class="line">    d = d + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">11</span>, b = <span class="number">111</span>, c = <span class="number">1111</span>, d = <span class="number">11111</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="string">" d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    partial(demo, a, <span class="built_in">std</span>::ref(b))(c, <span class="built_in">std</span>::ref(d));</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="string">" d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>stl排序(240)</title>
    <link href="https://xuecat.github.io/2018/07/28/240/"/>
    <id>https://xuecat.github.io/2018/07/28/240/</id>
    <published>2018-07-28T08:09:45.000Z</published>
    <updated>2018-07-28T09:16:01.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">以前有笔记，但忘了放哪了，再做一次吧</blockquote>

<p><img src="/picture/240.jpg" alt=""></p>
<ul>
<li>stable_sort</li>
<li>partial_sort</li>
<li>nth_element</li>
<li>partition和stable_partition</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> w&amp; l, <span class="keyword">const</span> w&amp; r)</span> </span>&#123;...&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifunc</span><span class="params">(<span class="keyword">const</span> w&amp; c)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<h4 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h4><pre><code>只排一部分：`partial_sort(w.begin(),w.beging()+20,w.end(),func)`只对前20个元素排
</code></pre><h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h4><pre><code>只分界:`nth_element(w.begin(),w.beging()+20,w.end(),func)`
将最后的20个元素放前面，但它不会像前面那个函数，这个函数不会排序，只是单纯放前面
</code></pre><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><pre><code>前面俩个只会比较元素，当判断元素属性时呢
`partition(w.begin(), w.end(), ifunc)`功能类似`partial_sort`但比较函数不同
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;以前有笔记，但忘了放哪了，再做一次吧&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/picture/240.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stable_sort&lt;/li&gt;

    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>mysql检索(239)</title>
    <link href="https://xuecat.github.io/2018/07/13/239/"/>
    <id>https://xuecat.github.io/2018/07/13/239/</id>
    <published>2018-07-12T16:49:11.000Z</published>
    <updated>2018-07-12T16:53:29.982Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Å, å，这是丹麦的</div><div class="line">Ä ä，这是德语的</div><div class="line">A <span class="selector-tag">a</span> 这是英文得</div></pre></td></tr></table></figure>
<p>mysql里校对包含字符时有这些<code>like</code> <code>instr</code> <code>locate</code>,<br>但它们时建立在一个校对规则之上的,<br><code>_unicode_ci</code>不区分大小写<br><code>_general_ci</code>不区分大小写<br><code>*_cs</code>区分大小写<br><code>*_bin</code>用二进制存储</p>
<p>utf8_general_ci 校对速度快，但准确度稍差<br>utf8_unicode_ci 准确度高，但校对速度稍慢(所以最近那个sql问题我该改成这个)</p>
<p>utf8mb4字符集可以保存表情符号.</p>
<p>最后直接限定字符检索才成功，不明白为何改<code>_bin</code>也不成功。唉！<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbp_log_object <span class="keyword">as</span> a <span class="keyword">WHERE</span> <span class="keyword">locate</span>(<span class="string">'Ä'</span> <span class="keyword">collate</span> utf8_bin, a.objectname)&gt;<span class="number">0</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>orleans(238)</title>
    <link href="https://xuecat.github.io/2018/07/06/238/"/>
    <id>https://xuecat.github.io/2018/07/06/238/</id>
    <published>2018-07-06T13:00:29.000Z</published>
    <updated>2018-07-10T16:00:54.411Z</updated>
    
    <content type="html"><![CDATA[<p>这个亚马逊云素材同步代码是我至今最大坡度的代码<br>第一次有种想早点下班好回去恶补知识的感觉,可惜又不得不加班完成任务。</p>
<ol>
<li>silo 代表一个服务，可以是主节点也可以是副节点</li>
<li><p>grain 可以看作是一个单例进程，队列只有一个，会排队修改数据。相同类型的只要key不同，它们就互相独立</p>
</li>
<li><p>客户端一开始就会连接一个服务即silo.(GrainClient.Initialize)</p>
</li>
<li><p>StreamProvider订阅，无论是隐式还是显式，都要用this.stream.OnNextAsync(data)去分发<br>显式还是隐式都是一个grain，初始化注册订阅后才能使用</p>
</li>
</ol>
<ol>
<li><p>Orleans.Immutable 这个是由于和grain的方法调用传参是一次深拷贝<br>grain之间通信，silo之间通信也是深拷贝。<br>为了避免，所以用这个来控制，避免深拷贝。</p>
</li>
<li><p>Orleans永远不会在执行Task的中途创造另一个Task,所以要求程序代码在执行Task的中途,不要开辟多线程.不然会报错或者会破坏单线程机制.如果真的有需要创造额外的task.</p>
</li>
<li><p><code>StatelessWorker</code>的<code>grain</code>，状态无关类型；可以在集群的多个silo里,每一个silo都创造一个相同标识的Grain。 针对此类grain的请求,都只在第一个接受到请求的silo里执行。 Orleans会在所有此类grain忙的时候,自动增加一个</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个亚马逊云素材同步代码是我至今最大坡度的代码&lt;br&gt;第一次有种想早点下班好回去恶补知识的感觉,可惜又不得不加班完成任务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;silo 代表一个服务，可以是主节点也可以是副节点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;grain 可以看作是一个单例进程，队列只有一个
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="分布式" scheme="https://xuecat.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>せいかつの日記(237)</title>
    <link href="https://xuecat.github.io/2018/07/04/237/"/>
    <id>https://xuecat.github.io/2018/07/04/237/</id>
    <published>2018-07-03T16:06:56.000Z</published>
    <updated>2018-08-06T15:11:13.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/237.png" alt=""></p>
<hr>
<pre><code>見ないでくたさい、ただ馬鹿な話しです
</code></pre><hr>
<h2 id="2018-7-3"><a href="#2018-7-3" class="headerlink" title="2018/7/3"></a>2018/7/3</h2><p>やっと、reactのプロジェクトおわりました、少しごめなことあるですけれど。</p>
<p>も、次の仕事用意してる</p>
<p>Amazon cloud synchronization</p>
<p>ああ！！メチや　メチや、難しいです；頭もだめちや</p>
<h2 id="2018-7-6"><a href="#2018-7-6" class="headerlink" title="2018/7/6"></a>2018/7/6</h2><p>ああ！あ！　ついに、負け犬をなちゃた<br>残業中に食物をあげで、そんな事はまったく思わなかったです。<br>相手は強すぎる、俺は彼の前に全然駄目です。<br>ちょっとだけない。。。。。、悲しいです。<br>どうするつもり、僕もわからない。<br>せめて答えをもらう</p>
<h2 id="2018-7-9"><a href="#2018-7-9" class="headerlink" title="2018/7/9"></a>2018/7/9</h2><p>山なほと仕事<br>恋は雨上がりのように</p>
<h2 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018/7/10"></a>2018/7/10</h2><p>父さんと母さんがきちゃった、猫も</p>
<h2 id="2018-7-24"><a href="#2018-7-24" class="headerlink" title="2018/7/24"></a>2018/7/24</h2><p>誰でもいい、彼女の事欲しい、ときとぎそう思うた<br>きっと、俺は寂しくすぎた<br>大切にされたかったら　安売りするな。</p>
<h2 id="2018-8-6"><a href="#2018-8-6" class="headerlink" title="2018/8/6"></a>2018/8/6</h2><p>ごめんれ、きっと僕は狡いです、罪がある。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/237.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;見ないでくたさい、ただ馬鹿な話しです
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&quot;2018-7-3&quot;&gt;&lt;a href=&quot;#2018-7-3&quot; class=
    
    </summary>
    
      <category term="生活" scheme="https://xuecat.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>decimal类型(236)</title>
    <link href="https://xuecat.github.io/2018/06/30/236/"/>
    <id>https://xuecat.github.io/2018/06/30/236/</id>
    <published>2018-06-30T07:59:25.000Z</published>
    <updated>2018-06-30T11:51:21.733Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>js forin顺序(235)</title>
    <link href="https://xuecat.github.io/2018/06/17/235/"/>
    <id>https://xuecat.github.io/2018/06/17/235/</id>
    <published>2018-06-17T06:21:10.000Z</published>
    <updated>2018-06-17T06:46:47.867Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/235.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>平时根本没时间写着，只好全缓存，周末更新上来，唉！！
得找个时间再去看下markdown语法了，排版真特么丑。
</code></pre><p>装逼封装了excel读写的js，forin排序居然用到了，笔记下：</p>
<pre><code>js for in顺序，不会按照定义顺序输出；好像浏览器没按以前标准了;
它处理方式是先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>stl的swap和(234)</title>
    <link href="https://xuecat.github.io/2018/06/17/234/"/>
    <id>https://xuecat.github.io/2018/06/17/234/</id>
    <published>2018-06-17T06:02:20.000Z</published>
    <updated>2018-06-17T06:46:39.547Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/234.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>去p站下图片越来越少了
</code></pre><h3 id="string和vector"><a href="#string和vector" class="headerlink" title="string和vector"></a>string和vector</h3><p>它们都是线性结构，只不过是堆而已。<br>它们都有reserve的概念，所以导致它们的预定义内存</p>
<p>释放内存的方法就是都是用<code>swap</code>, <code>string().swap(s)</code></p>
<p><code>swap</code>交换技巧实现内存释放思想：</p>
<p><strong><em><code>vector()</code>使用<code>vector</code>的默认构造函数建立临时<code>vector</code>对象，再在该临对象上调用<code>swap</code>成员，<code>swap</code>调用之后对象<code>myvector</code>占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="STL" scheme="https://xuecat.github.io/categories/STL/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>c++CRTP和typename与class的区别233</title>
    <link href="https://xuecat.github.io/2018/05/26/233/"/>
    <id>https://xuecat.github.io/2018/05/26/233/</id>
    <published>2018-05-26T08:38:00.000Z</published>
    <updated>2018-06-17T06:25:24.194Z</updated>
    
    <content type="html"><![CDATA[<p><code>Curiously Recurring Template Prattern</code>即人们称的静态多态<br>由于c++的多态不能将基类的虚函数定义为模板函数，所以出现的它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> D&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(D t)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>).funcImpl(t);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base : <span class="keyword">public</span> BaseClass&lt;Base&gt;</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> BaseClass&lt;Derive&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	BaseClass&lt;Derive&gt; der;</div><div class="line">	der.Func(<span class="number">2</span>);<span class="comment">//base 2</span></div><div class="line"></div><div class="line">	BaseClass&lt;Base&gt; bas;</div><div class="line">	bas.Func(<span class="number">4</span>);<span class="comment">//derive 4</span></div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此，多态就能使用模板函数了</p>
<hr>
<p><strong>怕是最近js写多了，这个都忘了，羞愧啊！！</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> MyClass&#123;</div><div class="line">    <span class="keyword">typename</span> T::SubType * ptr;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，typename指出SubType是class T中定义的一个类别，因此ptr是一个指向T::SubType型别的指针。如果没有关键字typename，SubType会被当成一个static成员，于是<br>T::SubType * ptr<br>会被解释为型别T内的数值SubType与ptr的乘积。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Curiously Recurring Template Prattern&lt;/code&gt;即人们称的静态多态&lt;br&gt;由于c++的多态不能将基类的虚函数定义为模板函数，所以出现的它&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>数据库遇见的一个问题(232)</title>
    <link href="https://xuecat.github.io/2018/05/06/232/"/>
    <id>https://xuecat.github.io/2018/05/06/232/</id>
    <published>2018-05-06T04:16:40.000Z</published>
    <updated>2018-05-06T04:21:10.090Z</updated>
    
    <content type="html"><![CDATA[<p>今天丹麦现场问题：<br>检索丹麦字符(长的像A,又不是A),出现英文A匹配和丹麦字符匹配。</p>
<p>最后发现是mysql的like语句，后面用locate语句精确才没把英文检索出来。<br>查了很久google和官方,并未给解释为啥like的模糊匹配是如此，大多讲locate比like高效。<br>所以写下记录，以后请问！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天丹麦现场问题：&lt;br&gt;检索丹麦字符(长的像A,又不是A),出现英文A匹配和丹麦字符匹配。&lt;/p&gt;
&lt;p&gt;最后发现是mysql的like语句，后面用locate语句精确才没把英文检索出来。&lt;br&gt;查了很久google和官方,并未给解释为啥like的模糊匹配是如此，大多讲l
    
    </summary>
    
      <category term="数据库" scheme="https://xuecat.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://xuecat.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>c++记录(231)</title>
    <link href="https://xuecat.github.io/2018/05/06/231/"/>
    <id>https://xuecat.github.io/2018/05/06/231/</id>
    <published>2018-05-06T04:03:21.000Z</published>
    <updated>2018-09-22T17:57:18.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a><strong><strong>数组检测</strong></strong></h2><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(<span class="number">0</span>[t]);<span class="comment">//可以检测这个是数组还是类：对数组来说0[t] t[0]都是一样的。但是对类来说，这是个操作函数(一定要实现它的operator函数哦)</span></div></pre></td></tr></table></figure>
</code></pre><h2 id="类完整性判断"><a href="#类完整性判断" class="headerlink" title="类完整性判断"></a><strong><strong>类完整性判断</strong></strong></h2><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">typedef</span> <span class="keyword">char</span> tt_f[<span class="keyword">sizeof</span>(f) ? <span class="number">1</span> : <span class="number">-1</span>];</div><div class="line">(<span class="keyword">void</span>)<span class="keyword">sizeof</span>(tt_f);</div><div class="line">   <span class="comment">//要注意sizeof的执行是编译期间执行的</span></div><div class="line">   <span class="comment">//所以当类不完整 sizof(f)为0; char[-1]就会编译错误</span></div></pre></td></tr></table></figure>
</code></pre><p><strong><strong>循环删除</strong></strong><br>循环删除由于存在访问异常的情况,<br>有一种方法，即解决访问问题，又能删除想要的。</p>
<h2 id="所以尾部删除好点"><a href="#所以尾部删除好点" class="headerlink" title="所以尾部删除好点"></a>所以尾部删除好点</h2><pre><code><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (<span class="name">int</span> i = f.Count - <span class="number">1</span><span class="comment">; i &gt;= 0; i--)</span></div><div class="line">&#123;</div><div class="line">    if (<span class="name">f</span>[i] &gt; <span class="number">5</span>)</div><div class="line">    &#123;</div><div class="line">        f.RemoveAt(<span class="name">i</span>)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组检测&quot;&gt;&lt;a href=&quot;#数组检测&quot; class=&quot;headerlink&quot; title=&quot;数组检测&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;strong&gt;数组检测&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highl
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c#杂项笔记(230)</title>
    <link href="https://xuecat.github.io/2018/02/28/230/"/>
    <id>https://xuecat.github.io/2018/02/28/230/</id>
    <published>2018-02-28T15:34:14.000Z</published>
    <updated>2018-07-02T16:31:02.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p> 同步函数执行到async时会同步执行,当在async里遇见await时，会跳出async函数到外部继续执行。<br> await执行完了后再执行async里面await之后的代码</p>
<p> async函数由于返回的是task类型，注意属性有同步类型</p>
<ol>
<li>函数参数不能有out ref，必须返回Task<ol>
<li>不应混合使用同步和异步代码，异步最好始终异步<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static class DeadlockDemo</div><div class="line">&#123;</div><div class="line">    private static async Task DelayAsync()</div><div class="line">    &#123;</div><div class="line">        await Task.Delay(1000);</div><div class="line">    &#125;</div><div class="line">    // This method causes a deadlock when called in a GUI or ASP.NET context.</div><div class="line">    public static void Test()</div><div class="line">    &#123;</div><div class="line">        //开始延迟函数</div><div class="line">        var delayTask = DelayAsync();</div><div class="line">        // 等待延迟完成</div><div class="line">        delayTask.Wait();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//test方法在gui和aps.net会出现死锁，控制台不会</div><div class="line">//这种死锁的根本原因是 await 处理上下文的方式</div><div class="line">//默认情况下，当等待未完成的 Task 时，会捕获当前“上下文”，在 Task 完成时使用该上下文恢复方法的执行</div><div class="line">//GUI 和 ASP.NET 应用程序具有 SynchronizationContext，它每次仅允许一个代码区块运行。 </div><div class="line">//当 await 完成时，它会尝试在捕获的上下文中执行 async 方法的剩余部分。 </div><div class="line">//但是该上下文已含有一个线程，该线程在（同步）等待 async 方法完成。它们相互等待对方，从而导致死锁。</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>await不像Task.Run()，它并不会创建线程来执行，只会移交权限来继续执行。</p>
</li>
<li><p>我一开始想这玩意，不创建新线程咋个优化呢。后面他们说会挂起执行其它函数，这样并发的时候就能很好处理，不会卡住。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;async-await&quot;&gt;&lt;a href=&quot;#async-await&quot; class=&quot;headerlink&quot; title=&quot;async await&quot;&gt;&lt;/a&gt;async await&lt;/h3&gt;&lt;p&gt; 同步函数执行到async时会同步执行,当在async里遇见awai
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>JS札记——网上看的装逼写法(229)</title>
    <link href="https://xuecat.github.io/2018/01/25/229/"/>
    <id>https://xuecat.github.io/2018/01/25/229/</id>
    <published>2018-01-25T12:54:28.000Z</published>
    <updated>2018-04-23T00:34:53.822Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/229.jpg" alt=""></p>
<h3 id="JS札记"><a href="#JS札记" class="headerlink" title="JS札记"></a>JS札记</h3><p> 数字取整:<br> <code>~~</code> 其实这是个按位非的运算符做了俩次<br> <code>2.33|0</code><br> <code>2.33&gt;&gt;0</code></p>
<p> 字符转数字:<br> <code>var a =&#39;1&#39;; +a;</code> 它用隐式转换来的</p>
<p> 类型判断:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> d == <span class="string">"string"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">d <span class="keyword">instanceof</span> Person;<span class="comment">//判断constructor.prototype是否存在于要检测对象的原型链上. 所以对number string boolean无效</span></div></pre></td></tr></table></figure></p>
<p> parseInt范围:<br> <code>parseInt(0.0000008)</code>//这个结果是8, 小数点后7位出错<br> <code>parseInt(10000000000023291)</code>//20位出错</p>
<p> 数组去重:<br> <code>[...new Set([1, &quot;1&quot;, 2, 1, 1, 3])]</code></p>
<p> 指定长度填充:<br> 以前就在想了，赶紧笔记: <code>let aa = Array(6).fill(8)</code> 长度6,填充8</p>
<p> 短路表达式:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = b&amp;&amp;<span class="number">1</span>; <span class="keyword">if</span> (b) a=<span class="number">1</span>; <span class="keyword">else</span> a=b;</div><div class="line"><span class="keyword">var</span> a = b||<span class="number">1</span>; <span class="keyword">if</span> (b) a=b; <span class="keyword">else</span> a=<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p> 高逼格创建函数:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'a++; return a+1;'</span>);</div><div class="line">f(<span class="number">1</span>)<span class="comment">//3</span></div><div class="line"><span class="comment">//函数字符化</span></div></pre></td></tr></table></figure></p>
<p> 立即执行函数:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)();</div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div></pre></td></tr></table></figure></p>
<h3 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><ol>
<li>xss安全，对url和内容做过滤，防止嵌入js执行代码</li>
<li>csp, 通过服务器应答头或者html的<code>META</code>标签,限制请求源</li>
</ol>
<h3 id="浏览器Console命令"><a href="#浏览器Console命令" class="headerlink" title="浏览器Console命令"></a>浏览器Console命令</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log();</div><div class="line"><span class="built_in">console</span>.dir();<span class="comment">//显示一个对象所有属性和方法</span></div><div class="line"><span class="built_in">console</span>.dirxml();<span class="comment">//显示网页某节点所包含的html/xml</span></div><div class="line"><span class="built_in">console</span>.assert();<span class="comment">//弹框</span></div><div class="line"><span class="built_in">console</span>.trace();<span class="comment">//附带显示行数</span></div><div class="line"><span class="built_in">console</span>.time();<span class="built_in">console</span>.timeEnd();用来显示代码运行时间</div></pre></td></tr></table></figure>
<h3 id="浏览器其它"><a href="#浏览器其它" class="headerlink" title="浏览器其它"></a>浏览器其它</h3><p> 浏览器能设置条件语句断点<br> 左边可以直接启动手机模式,这样就能看手机状态下的浏览情况</p>
<h3 id="CSS黑魔法"><a href="#CSS黑魔法" class="headerlink" title="CSS黑魔法"></a>CSS黑魔法</h3><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p> 强缓存:</p>
<ul>
<li>当头的Cache-Control的max-age(最多有效时间)/s-maxage(代理最大有效时间) 被设置时, 用头的date和当前时间比对</li>
<li><p>当无 头的cache-control只有头的expires时,则用expires和当前时间对比</p>
<p>协商缓存:</p>
</li>
<li>头有last-modiied和etag,会向服务器请求是否失效,请求包加头if-modified-since和if-none-match.<br>服务器回应304浏览器就本地加载，否则重新发送数据</li>
</ul>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p> 这个属性来源于css3属性<br> 从里到外,margin-&gt;border-&gt;padding-&gt;content.</p>
<ul>
<li><p>content-box标准盒。height指content的高,width指content的宽</p>
</li>
<li><p>border-box怪异盒。height指content+padding+border的高,width指content+padding+border的高</p>
</li>
</ul>
<p>网上说在网页的顶部加上 doctype 声明。假如不加 doctype 声明，那么各个浏览器会根据自己的行为去理解网页。</p>
<h3 id="浏览器安全-1"><a href="#浏览器安全-1" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><p> CSRF(跨站点请求伪造): 用户c打开网站a，未推出a之前，打开网站b。网站b发出请求要求访问网站a，来利用未销毁的cookie来达到攻击的目的</p>
<p> 防范方法:</p>
<ul>
<li>验证http referer字段，这个字段表示http请求来源地址</li>
<li>请求接口添加token验证</li>
<li><p>http添加自定义属性</p>
<p>XSS(跨站脚本攻击):调用web接口时，提交js代码进去，下次访问页面会执行js代码达到攻击</p>
<p>防范方法:</p>
</li>
<li>输入数据编码处理(HTML Entity)</li>
<li>输入数据过滤</li>
<li>矫正</li>
</ul>
<h3 id="JS技巧"><a href="#JS技巧" class="headerlink" title="JS技巧"></a>JS技巧</h3><p><code>[]+{}</code> 非primitive type(即值类型)的<code>+</code>运算,对于数组和<code>object</code>,其实都是在调用<code>toString</code>方法.<br>数组<code>[]</code>的<code>toString</code>其实就是调用<code>.join()</code>方法.<br><code>Object</code>转<code>String</code>就是<code>[object Object]</code>(用<code>String({})</code>测试)</p>
<p><code>[]+{}</code>相当于””+”[object Object]”<br><code>{}+[]</code> 会变成俩端<code>{}</code>和<code>+[]</code>,一个代码段一个执行语句,由于后面是空且被隐式转换了,所以结果是<code>0</code><br><code>{}+{}</code></p>
<h3 id="JS有6个假值-false-null-undefined-0-“”-NaN"><a href="#JS有6个假值-false-null-undefined-0-“”-NaN" class="headerlink" title="JS有6个假值:false null undefined 0 “” NaN"></a>JS有6个假值:false null undefined 0 “” NaN</h3><p> <strong>但是它们之间并非都相等</strong><br> 以下是相等的:<br> <code>false==0</code><br> <code>false==&#39;&#39;</code><br> <code>null==undefined</code><br> <code>0==&#39;&#39;</code></p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//es5</span></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">var</span> item = a[i];</div><div class="line">    (res.indexOf(item) === <span class="number">-1</span>) &amp;&amp; res.push(item);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="浏览器渲染和服务器渲染"><a href="#浏览器渲染和服务器渲染" class="headerlink" title="浏览器渲染和服务器渲染"></a>浏览器渲染和服务器渲染</h3><p> 浏览器端渲染，指的是用js去生成html，前端做路由。举例：React, Vue等等前端框架。适合单页面应用程序。</p>
<p> 服务器端渲染，指的是用后台语言通过一些模版引擎生成html。举例：PHP文件、JSP文件、Python的Flask配合Jinja引擎、Django框架、Java配合vm模版引擎、NodeJS配合Jade。适合多页面应用。</p>
<p> <strong>浏览器渲染过程</strong><br> DOM Tree：浏览器将HTML解析成树形的数据结构。<br> CSS Rule Tree：浏览器将CSS解析成树形的数据结构。<br> Render Tree: DOM和CSSOM合并后生成Render Tree。<br> layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br> painting: 按照算出来的规则，通过显卡，把内容画到屏幕上</p>
<p> 过程是异步的，下载多少内容，构建多少render树<br> （1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染(要尽量避免它:操作dom 元素尺寸变化 css属性变化)。<br> （2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。 </p>
<p> <strong>浏览器优化</strong><br> 减少refow/repaint：</p>
<ul>
<li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</li>
<li>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的</li>
<li><p>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局</p>
<p><strong>CSS优化</strong><br>CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dom深度尽量浅</div><div class="line">减少inline javascript(<span class="keyword">script</span>嵌入那种)、css的数量</div><div class="line">不要为<span class="built_in">id</span>选择器指定类名或是标签，因为<span class="built_in">id</span>可以唯一确定一个元素</div><div class="line">避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;<span class="comment">#tp p&#123;&#125; 子选择符：#tp&gt;p&#123;&#125;</span></div><div class="line">避免使用通配符</div></pre></td></tr></table></figure>
<p><strong>js的下载和执行会阻塞Dom树的构建</strong></p>
</li>
</ul>
<h3 id="js数组"><a href="#js数组" class="headerlink" title="js数组"></a>js数组</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> tt = [<span class="string">"22"</span>, <span class="string">"55"</span>, <span class="string">"88"</span>];</div><div class="line">tt[<span class="number">7</span>] = <span class="number">3</span>;</div><div class="line">t.length<span class="comment">//8 是不是很惊讶，然而t[6]是undefined</span></div></pre></td></tr></table></figure>
<h3 id="js模块加载"><a href="#js模块加载" class="headerlink" title="js模块加载"></a>js模块加载</h3><p> commonjs:nodejs应用最多，它的require是同步的，运行时确定模块依赖关系，先加载整个模块，直接生产对象1<br> 再从对象上读取方法<br> amd:requirejs就实现了amd规范，异步，运行时加载<br> es6：编译时确定依赖关系，导出任意值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/229.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;JS札记&quot;&gt;&lt;a href=&quot;#JS札记&quot; class=&quot;headerlink&quot; title=&quot;JS札记&quot;&gt;&lt;/a&gt;JS札记&lt;/h3&gt;&lt;p&gt; 数字取整:&lt;br&gt; &lt;code&gt;~~
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="学习看书笔记" scheme="https://xuecat.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%9C%8B%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>react插件(228)</title>
    <link href="https://xuecat.github.io/2017/12/25/228/"/>
    <id>https://xuecat.github.io/2017/12/25/228/</id>
    <published>2017-12-25T15:02:02.000Z</published>
    <updated>2018-05-18T02:23:48.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-thunk"><a href="#react-thunk" class="headerlink" title="react-thunk"></a>react-thunk</h3><p> 我一开始觉得把<code>props.dispatch</code>当参数传总会异步的，但是当多个时就会分不清。</p>
<ol>
<li>只有<code>store</code>的<code>dispatch</code>后面才能跟<code>then</code>，其它都不能</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">tt</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dis</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> tt = dis(addTodo(<span class="string">'wangqiu'</span>));<span class="comment">//函数出入的参数就是dispatch，所以以次来异步发action</span></div><div class="line">    <span class="keyword">return</span> dis(toggleTodo(tt));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">   &lt;TodoList</div><div class="line">          todos=&#123;visibleTodos&#125;</div><div class="line">          onTodoClick=&#123;index =&gt;</div><div class="line">            &#123;dispatch(test(index))&#125;<span class="comment">//普遍做法如此，给dispatch传个函数进去</span></div><div class="line">          &#125; /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p> <code>https://www.w3cplus.com/javascript/immutable-js.html</code></p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p> 最近看<code>react-redux</code>,<br> <code>connect</code>中的参数有<code>mapStateToProps</code>和<code>mapDispatchToProps</code>,剩下俩个不说,<br> 他们第二个参数<code>ownProps</code>,指的是当前组件的属性<br> 它指的是<code>mapStateToProps</code>之外的属性(即通过xml属性传递的属性),state转prop后自己是能访问到的。</p>
<pre><code>connect的第二个参数,redux会给mapDispatchToProps传一个dispatch参数，拿到后可以自己做，它的返回值会被直接注入到组件的props里面。我喜欢直接返回dispatch
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mapDispatchToProps = dispatch =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">            onTodoClick: id =&gt; &#123;</div><div class="line">            dispatch(toggleTodo(id))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a>redux-actions</h4><p> createAction<br> 以前:<br> <code>const startAction = () =&gt; ({type:START})</code><br> 使用:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;createAction&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">const</span> startAction = createAction(START);</div></pre></td></tr></table></figure></p>
<p> handleactions<br> 以前:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">state=defaultState, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> START : &#123;<span class="keyword">return</span> &#123;...state, runStatus:<span class="literal">true</span>&#125;&#125;;<span class="comment">//es6的解构太方便了，会直接覆盖</span></div><div class="line">        <span class="keyword">case</span> STOP: &#123;<span class="keyword">return</span> &#123;...state, runStatus:<span class="literal">false</span>&#125;&#125;;<span class="comment">//同名属性覆盖</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 使用:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">const</span> time = handleActions(&#123;</div><div class="line">    START:(state, action) =&gt; (&#123;...state, runStatus:<span class="literal">true</span>&#125;),</div><div class="line">    STOP:(state, action) =&gt; (&#123;...state, runStatus:<span class="literal">false</span>&#125;),</div><div class="line">&#125;, defaultState);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;react-thunk&quot;&gt;&lt;a href=&quot;#react-thunk&quot; class=&quot;headerlink&quot; title=&quot;react-thunk&quot;&gt;&lt;/a&gt;react-thunk&lt;/h3&gt;&lt;p&gt; 我一开始觉得把&lt;code&gt;props.dispatch&lt;/code
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>c++11左右值 (226)</title>
    <link href="https://xuecat.github.io/2017/12/18/226/"/>
    <id>https://xuecat.github.io/2017/12/18/226/</id>
    <published>2017-12-18T12:15:38.000Z</published>
    <updated>2017-12-20T15:09:39.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-左右值"><a href="#C-左右值" class="headerlink" title="C++左右值"></a>C++左右值</h3><p> 左值指即能出现等号左边，也能出现在右边的变量（通常指有变量名的值）<br> 右值值只能出现等号右边的值（通常指无变量名的值，函数返回和表达式，常量——不跟对象关联的常量）<br> c++11在上面右值多个将亡值<br><code>move</code>右转左 <code>forward</code>左转右</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyClass <span class="title">fun</span> <span class="params">()</span> </span>&#123;MyClass <span class="keyword">return</span> s;&#125;</div><div class="line">MyClass s= fun();</div><div class="line">MyClass&amp; s = fun();</div><div class="line">MyClass&amp;&amp; s = fun();<span class="comment">//这三个全是调用移动构造函数</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C-左右值&quot;&gt;&lt;a href=&quot;#C-左右值&quot; class=&quot;headerlink&quot; title=&quot;C++左右值&quot;&gt;&lt;/a&gt;C++左右值&lt;/h3&gt;&lt;p&gt; 左值指即能出现等号左边，也能出现在右边的变量（通常指有变量名的值）&lt;br&gt; 右值值只能出现等号右边的值（通常指
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS继承和函数式编程的curry等(227)</title>
    <link href="https://xuecat.github.io/2017/12/18/227/"/>
    <id>https://xuecat.github.io/2017/12/18/227/</id>
    <published>2017-12-18T12:15:38.000Z</published>
    <updated>2018-01-30T14:18:53.538Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/227.jpg" alt=""></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>每个函数对象有个一个<code>prototype</code>(显式原型),指向<code>constructor</code>;但<code>constructor.prototype</code>指向本身.</li>
<li>实例只有<code>__proto__</code>(隐式原型)</li>
<li>所有实例需要共享的属性和方法,都可放在<code>prototype</code>;不需要则放在构造函数中</li>
<li>实例的<code>__proto__</code>指向构造该对象的构造函数的原型即<code>**.prototype</code></li>
</ul>
<h3 id="es5-6种继承"><a href="#es5-6种继承" class="headerlink" title="es5 6种继承"></a>es5 6种继承</h3><p><strong>来自原型对象的引用属性是所有实例共享的</strong></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>简单链</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Sub.prototype = <span class="keyword">new</span> Super();<span class="comment">//共享原型对象，arr是引用类型</span></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</div><div class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</div><div class="line"></div><div class="line"><span class="comment">//1.无法构造函数传参</span></div><div class="line">sub1.val = <span class="number">2</span>;<span class="comment">//不会影响sub2</span></div><div class="line">sub1.arr.push(<span class="number">2</span>);<span class="comment">//会影响sub2</span></div></pre></td></tr></table></figure>
<p> <strong>补充</strong><br>  对继承的简单链原理补充<br>我一直在想那样的影响为何有,今天想通了,来做点笔记</p>
<p><strong>补充:</strong> <br></p>
<ul>
<li>call: 替换上下文,可以想象成替换<code>this</code></li>
<li>new:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</div><div class="line">obj.__proto__ = Base.prototype;</div><div class="line">Base.call(obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>call</code>替换后，它还会再调用一遍<code>Base</code>函数,保证有成员变量</p>
<p><strong>过程分析:</strong><br></p>
<ul>
<li>第一行的<code>new Super</code>直接导致<code>Sub.prototype</code>拥有了<code>val</code>和<code>arr</code></li>
<li>二三行的<code>new Sub</code>只是将<code>__proto__</code>指向了<code>Sub.prototype</code></li>
</ul>
<p>所以使用<code>sub.val</code> <code>sub.arr</code>却也只是访问<code>Sub.prototype</code>上面的东西而已</p>
<p>如此说来,大家都访问一个东西却为何<code>val</code>不影响呢?<br><br>因为在第6行里是个创建而不是修改</p>
<p>第六行是对<code>sub1</code>创建一个私有属性并赋值<br>第七行是访问<code>sub1</code>的<code>arr</code>,然而没有从原型链上拿去了</p>
<ul>
<li>简单链很好,就怕某地出错,记住它们是访问一个</li>
<li>借用构造函数这个太浪费了不考虑</li>
<li>new的数量不是很多倒是可以用用组合继承</li>
</ul>
</li>
<li><p>借用构造函数</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val); <span class="comment">//1.子类互不影响 2.但是复制了父类实例属性导致内存增加 3.call不会复制原型链</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure>
</li>
<li><p>组合继承</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line"></div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//函数全放入原型中，方便共享</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val);<span class="comment">//保留传参功能</span></div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();<span class="comment">//1. 函数复用 2.构造函数传参 3.原型多余内存</span></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>寄生组合继承</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">//构建只有原型链的空对象</span></div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> proto = beget(Super.prototype);</div><div class="line">proto.constructor = Sub;</div><div class="line">Sub.prototype = proto;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();<span class="comment">//1.确实解决了以上所有问题 2.书写太麻烦了</span></div></pre></td></tr></table></figure>
</li>
<li><p>原型(感觉没意义)</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Super();</div><div class="line"><span class="keyword">var</span> sub = beget(sup);</div><div class="line">sub.v = v;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="es6继承"><a href="#es6继承" class="headerlink" title="es6继承"></a>es6继承</h3><p>上面的<code>寄生组合继承</code>同，多个<code>static</code>定义静态属性</p>
<h3 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h3><p> 这个概念是存储传入参数，够了才执行函数<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fun = a=&gt; b=&gt; c=&gt; &#123;<span class="keyword">return</span> a+b+c&#125;<span class="comment">//注意return</span></div><div class="line"><span class="keyword">let</span> fun1 = fun(<span class="number">1</span>)<span class="comment">//存储函数</span></div><div class="line"><span class="keyword">let</span> fun2 = fun1(<span class="number">2</span>);</div><div class="line"><span class="keyword">let</span> fun3 = fun2(<span class="number">3</span>);<span class="comment">//6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> fun1 = fun(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)<span class="comment">//6, 参数多了会报错</span></div></pre></td></tr></table></figure></p>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>  这个es6并没有实现，但是很多库有这个函数<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = (firstName, lastName) =&gt; <span class="string">'hello, '</span> + firstName + <span class="string">' '</span> + lastName</div><div class="line"><span class="keyword">var</span> toUpper = str =&gt; str.toUpperCase()</div><div class="line"><span class="keyword">var</span> fn = compose(toUpper, greeting)</div><div class="line"><span class="built_in">console</span>.log(fn(<span class="string">'jack'</span>, <span class="string">'smith'</span>))</div><div class="line"><span class="comment">// ‘HELLO，JACK SMITH’</span></div></pre></td></tr></table></figure></p>
<ul>
<li>compose的参数是函数，返回的也是一个函数</li>
<li>因为除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的</li>
<li>compsoe函数可以接受任意的参数，所有的参数都是函数，且执行方向是自右向左的，初始函数一定放到参数的最右面</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/227.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个函数对象有个一个&lt;code&gt;p
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="学习看书笔记" scheme="https://xuecat.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%9C%8B%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++函数指针模板又一次说明(225)</title>
    <link href="https://xuecat.github.io/2017/10/26/225/"/>
    <id>https://xuecat.github.io/2017/10/26/225/</id>
    <published>2017-10-26T15:50:30.000Z</published>
    <updated>2017-11-13T13:15:50.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/picture/225.jpg" alt=""></p>
<h3 id="函数指针又一次说明"><a href="#函数指针又一次说明" class="headerlink" title="函数指针又一次说明"></a>函数指针又一次说明</h3><p>今天看rapidjson的源码，看到一句默认操作符转换函数指针的代码懵逼了居然。。<br>好歹也是读了十来本c++的书了，还这么2。<br>顺便做笔记。</p>
<ul>
<li>按照effictive说法，结构体比函数指针快。所以用<code>operator()</code>代替函数指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我按照它代码的写法，尝试了下。感觉默认指针函数只能用在if语句上来走个默认转换</span></div><div class="line"><span class="keyword">struct</span> Prs &#123;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(Prs::*Boolt)</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">bool</span> m_bR;</div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Boolt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !IsEr() ? &amp;Prs::IsEr : <span class="literal">NULL</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsEr</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> m_bR == <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ah</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Prs &amp;f, Prs::Boolt df)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> ((f.*df)())</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> a-b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Prs d;</div><div class="line">d.m_bR = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (d)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> f = ah(<span class="number">1</span>, <span class="number">2</span>, d, d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用函数指针这个看上去没有创建对象，其实是初始化了一个临时对象再来调用它的operator()函数</span></div><div class="line"><span class="comment">//感觉用这个方法方便点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> TP&gt;</div><div class="line"><span class="keyword">struct</span> PrsT &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function">TR <span class="title">operator</span><span class="params">()</span> <span class="params">(TP a, TP b)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a+b;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> TP, <span class="keyword">typename</span> Fun&gt;</div><div class="line"><span class="function">TR <span class="title">aht</span><span class="params">(TR a, TP b, Fun f)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> f(a, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Prs &#123;</div><div class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(Prs::*Boolt)</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">bool</span> m_bR;</div><div class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Boolt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> !IsEr() ? &amp;Prs::IsEr : <span class="literal">NULL</span>;</div><div class="line">	&#125;;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsEr</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> m_bR == <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> ff = aht(<span class="number">1</span>, <span class="number">2</span>, PrsT&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/picture/225.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数指针又一次说明&quot;&gt;&lt;a href=&quot;#函数指针又一次说明&quot; class=&quot;headerlink&quot; title=&quot;函数指针又一次说明&quot;&gt;&lt;/a&gt;函数指针又一次说明&lt;/h3&gt;&lt;p
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="指针" scheme="https://xuecat.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
